# C++软件开发总结

## 一、C++基础

### 1、引用和指针的区别

- **指针是一个实体**，需要分配内存空间。**引用只是变量的别名**，不需要分配内存空间。
- 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。
- 有**多级指针**，但是没有多级引用，只能有**一级引用**。
-  **自增运算结果不一样**：指针：指向下一个空间，引用：引用的变量值加1
- **sizeof计算的大小不一样**：sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
- 引用访问一个变量是**直接**访问，而指针访问一个变量是**间接**访问。
- 使用指针前最好做类型检查，防止野指针的出现；
- 引用底层是通过指针实现的；
- 作为参数时也不同，传指针的实质**传递指针的地址**；传引用的实质是**传递变量的地址**。

### 2、形参和实参的区别

- **形参变量只有在被调用时才分配内存单元**，在调用结束时， 即刻释放所分配的内存单元（由编译器释放）。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
- 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在**进行函数调用时，实参都必须具有确定的值**， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
- **实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误**。
- **函数调用中发生的数据传送是单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。

### 3、static的用法和作用

- 最重要的一条：**隐藏**。（static函数，static变量均可）当同时**编译多个文件时，加static前缀的全局变量和函数都只在当前文件中可见**，未加static前缀的全局变量和函数都具有全局可见性。

- **保持变量内容的持久**，存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。

- **static变量默认初始化为0**，在静态数据区（全局变量和static变量），内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

- **C++中的类成员声明static**：

  1）**类的静态成员函数是属于整个类而非类的对象**，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。      

  2) **不能将静态成员函数定义为虚函数**，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义

  3）static类对象必须要在**类外进行初始化**，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化

### 4、static变量的初始化

- **编译时初始化**：静态变量本身是基本数据类型 ，且初始化值是常量，则初始化是在编译期间完成

~~~
static int val = 10
~~~

- **加载时初始化**：初始化过程在main函数前，程序被加载时立即进行的初始化

  1) 静态变量是一个基本数据类型，但初始化值非常量

~~~
static int *p = new int[8]
~~~

​	2）静态变量是类变量

~~~
class A{
public:
    A();
    ~A();
}
static A *a1 = new A();
~~~

- **运行时初始化**：初始化发生在变量第一次被引用

~~~
int fun(int x)
{
    static int a = x;
}
~~~

### 5、const基本使用

- 阻止一个**变量**被改变，可以使用const关键字。在定义该const变量时，必须对它进行初始化，如果类中含有const成员变量，则该变量需要在类的初始化列表中进行初始化；   

- 对于**指针**：顶层const（int *const a），指针本身不能被改变，底层const(const  int *a)，指针指向的值不能被改变

- 在一个**函数**声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；   

- 对于**类的成员函数**：

  ```
  ①const Stock & Stock::topval (②const Stock & s) ③const
  ```

  ①处const：确保返回的Stock对象在以后的使用中不能被修改 

  ②处const：确保此方法不修改传递的参数 S

  ③处const：保证此方法不修改调用它的对象（this），const对象只能调用const成员函数,不能调用非const函数

- const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；

### 6、extern用法

- extern修饰**变量**的声明：

  如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。

- extern修饰**函数**的声明：

  如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu）

- extern修饰符可用于指示C或者C++的混合编程：

  在C++源文件中的语句前面加上extern "C"，表明它按照类C的**编译和链接**规约来编译和链接，而不是C++的编译的链接规约。这样在类C的代码中就可以调用C++的函数或者变量等

### 7、深拷贝和浅拷贝

- 浅拷贝：仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。

  ![浅拷贝](F:\NOTE\C++开发总结\pic\浅拷贝.png)

- 深拷贝：开辟了一块新的内存地址用于存放复制的对象

  ![深拷贝](F:\NOTE\C++开发总结\pic\深拷贝.png)

### 8、C++模板，底层实现

编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过**具体类型**产生不同的函数；

编译器会对函数模板进行**两次编译**：在**声明**的地方对模板代码本身进行编译，生成简陋的函数模板原形，在**调用**的地方对参数替换后的代码进行编译，生成具体的函数原形。

### 9、C struct和C++ struct区别

-  C中struct是用户自定义数据类型（UDT），C++中struct是抽象数据类型（ADT），支持成员函数的定义，类似于class，可以实现继承和多态。
- C中struct是没有权限的设置的，c++中的struct可以设置访问权限，其默认为public，是对c中struct的扩展。
- C中必须在结构标记前加上struct，才能做结构类型名，而c++中不需要

### 10、左值右值

在C++11中所有的值必属于左值、右值两者之一，在C++11中可以**取地址**的就是左值，反之，不能取地址的就是右值（将亡值或纯右值）。同时左值是能够出现在**等号左边或等号右边**的变量(或表达式)，右值只能出现在**等号右边**的变量(或表达式)。

### 11、C语言的编译链接过程

- 基本过程

  **源代码－>预处理－>编译 - >汇编－>链接 - >可执行文件**

- 预处理

  处理宏定义替换、条件编译指令、头文件包含指令、特殊符号

- 编译阶段

  词法分析和语法分析，生成中间代码表示或汇编代码.s文件

- 汇编过程

  把汇编语言代码翻译成目标机器指令的过程，生成.o目标文件

- 链接阶段

  将有关的目标文件彼此相连接，生成可执行文件

### 12、容器内部删除一个元素

- 顺序容器

  erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；

  It = c.erase(it);

- 关联容器

  erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；

  c.erase(it++)

### 13、STL迭代器如何实现

迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载。

### 14、函数指针和指针函数

- **指针函数**

  他是一个函数，返回的是一个指针

  ~~~
  int *f(int a,int b);
  ~~~

- **函数指针**

  他是一个指针，指向函数的入口地址

  ~~~c++
  int （*Func）(int,int);
  int getsum(int a,int b)
  {
  	return a+b;
  }
  Func=&getsum;//取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址
  Func=getsum;
  //调用方式(*Func)(2,3) Func(2,3)
  ~~~

### 15、说说你对c和c++的看法，c和c++的区别

- C是面向过程的语言，而C++是面向对象的语言

  **面向对象**

  封装：将客观事物封装成抽象的类，可以把自己的数据和方法进行有选择性的开放。

  继承：一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类

  多态：运行时多态和编译时多态

- C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字

- C中的struct和C++的类，C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;

- C++支持函数重载，而C不支持函数重载

- C++中有引用，而C没有

### 16、c/c++的内存分配，详细说一下栈、堆、静态存储区

- **栈区**（stack），由**编译器**自动分配释放，存放函数的参数值，局部变量的值 
- **堆区**（heap）， —般由**程序员分配释放**，若程序员不释放，可能会出现内存泄露，程序结束时可能由OS（**操作系统**）回收。 New malloc 
- **全局区**（静态区），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（.data），未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bss)。程序结束后由系统释放。  
- **常量区**，专门用于存储常量。程序结束后由系统释放。
- **程序代码区**，存放函数体的二进制代码。 

### 17、堆与栈的区别

- 管理方式：对于栈来讲，是由**编译器**自动管理；对于堆来说，释放工作由程序员控制，容易产生memory leak。**内存泄露，即使用完对象后未释放对象内存，从而失去对这块内存的管理** 
- 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列
- 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长
- 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆的效率比栈要低得多

### 18、野指针是什么？如何检测内存泄漏？

- 野指针：指向被释放的内存或者没有访问权限的内存的指针。

- “野指针”的成因主要有3种：

  1）**指针变量没有被初始化**。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如
   char *p = NULL;
   char *str = new char(100);

  2）指针p被free或者delete之后，**没有置为NULL**；

  3）**指针操作超越了变量的作用范围**。

-  如何避免野指针：

  1）对指针进行初始化，

  ​	a）将指针初始化为NULL。

  ​	char *   p  = NULL;

  ​	b）用malloc分配内存

  ​	char * p = (char * )malloc(sizeof(char));

  ​	c）用已有合法的可访问的内存地址对指针初始化

  ​	char num[ 30] = {0};

  ​	char *p = num;

  2）指针用完后释放内存，将指针赋NULL。

  delete(p);

  p = NULL;

### 19、悬空指针和野指针有什么区别

- 野指针：没有初始化的指针
- 悬空指针：**一个指针的指向对象已被删除**，那么就成了悬空指针。p1和p2指向同一块内存，free(p1)后，p1和p2都是悬空指针
- 有时也把野指针和悬空指针统称为悬空指针

### 20、内存泄漏

- 内存泄漏

  内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；

- 后果

  只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种征兆：**性能下降到内存逐渐用完，导致另一个程序失败**；

- 解决方法

  智能指针

### 21、智能指针

- **什么是智能指针，为什么要使用智能指针？**

  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

- **常见的智能指针有哪些，怎么用？**

智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr。

1）shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

2）unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。

3）weak_ptr 是一种不控制对象生命周期的智能指针,它指向一个 shared_ptr 管理的对象. weak_ptr用来协助 shared_ptr 工作, 主要解决shared_ptr**循环引用**的问题，因为weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

- **手写智能指针**

  **unique_ptr**

  ~~~c++
  template<class T>
  class unique_ptr
  {
  public:
      unique_ptr(T *p = NULL):ptr(p){}
      T& operator*(){return  *ptr;}
      T* operator->(){return  ptr;}
      T* get_ptr(){return ptr;}
      ~unique_ptr()
      {
          if(ptr)
          {
              delete ptr;
              ptr = NULL;
          }
      }
   private:
      unique_ptr(unique_ptr<T> &p);//禁止调用拷贝构造和赋值运算符
      unique_ptr<T> &operator=(unique_ptr<T> &p);
      T *ptr;
  }
  ~~~

  **share_ptr**

  ~~~c++
  template<class T>
  class share_ptr
  {
   public:
      share_ptr(T *p = NULL):ptr(p),count(NULL)
      {
          if(count == NULL)
          {
              count = new int(1);
          }
      }
      share_ptr(share_ptr<T> &p):ptr(p.ptr),count(&(++ *p.count)){};
      T& operator*(){return *ptr};
      T* operator->(){return ptr};
      share_ptr<T> &operator=(share_ptr<T> &p)
      {
          if(this == &p)
              return *this;
          ++*p.count;
          if(this->ptr && 0 == --*this->count)
          {
              delete count;
              delete ptr;
          }
          this->ptr = p.ptr;
          this->count = p.count;
          return  *this;
      }
      ~share_ptr()
      {
          (*count)--;
          if(ptr && *count == 0)
          {
              delete ptr;
              delete count;
          }
      }
      int getRef()
      {
          return *count;
      }
   private:
      T* ptr;
      int *count;
  }
  int main()
  {
  
    share_ptr<string> pstr(new string("abc"));
    cout << "pstr:" << pstr.getRef() << " " << *pstr << endl;
   
    share_ptr<string> pstr2(pstr);
    cout << "pstr:" << pstr.getRef() << " " << *pstr << endl;
    cout << "pstr2:" << pstr2.getRef() << " " << *pstr2 << endl;
   
    share_ptr<string> pstr3(new string("hao"));
    cout << "pstr3:" << pstr3.getRef() << " " << *pstr3 << endl;
    
    pstr3 = pstr2;
    cout << "pstr:" << pstr.getRef() << " " << * pstr << endl;
    cout << "pstr2:" << pstr2.getRef() << " " << *pstr2 << endl;
    cout << "pstr3:" << pstr3.getRef() << " " << *pstr3 << endl;
   
    return 0;
  }
  ~~~

  ![share_ptr](F:\NOTE\C++开发总结\pic\share_ptr.PNG)

#### 21.1 shared_ptr

##### 21.1.1 初始化

可通过构造函数、std::make_shared<T>辅助函数和reset方法来初始化shared_ptr， 优先使用shared_ptr初始化，更高效

~~~c++
std::shared_ptr<int> p(new int(1));
std::shared_ptr<int> ptr,ptr2;
ptr = std::make_shared<int>(1);
ptr2.reset(new int(1));
~~~

##### 21.1.2 获取原始指针

~~~
std::shared_ptr<int> p(new int(2));
int *k = p.get();
~~~

##### 21.1.3 使用注意问题

1）不要用原始指针初始化多个shared_ptr

~~~c++
int *ptr = new int;
shared_ptr<int> p1(ptr);
shared_ptr<int> p2(ptr);//error!
~~~

2)不要在函数实参中创建shared_ptr

~~~c++
func(shared_ptr<int>(new int),g());
//正确写法
shared_ptr<int> p(new int);
func(p,g());
~~~

3）**std::enable_shared_from_this<A>**

让目标类通过派生std::enable_shared_from_this<A>类，然后使用基类的成员函数shared_from_this来返回this的shared_ptr

~~~c++
class A:public std::enable_shared_from_this<A>
{
public:
	std::shared_ptr<A> get()
	{
		return std::shared_from_this();
	}
}
std::shared_ptr<A> p(new A);
std::shared_ptr<A> ptr = p->get();
~~~

4）避免循环引用（通过weak_ptr解决）

### 22、new和malloc的区别

- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，**无须进行类型转换**，故new是符合类型安全性的操作符。而malloc内存分配成功则是**返回void *** ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- new会先调用**operator new函数**，申请足够的内存（通常**底层使用malloc实现**），delete先调用析构函数，然后调用**operator delete函数**释放内存（通常**底层使用free实现**）

### 23、new实现原理， delete是如何知道释放内存的大小

- new简单类型直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；
- new [] 一个对象数组时，C++ 在分配数组空间时**多分配了 4 个字节的大小，专门保存数组的大小**，在 delete [] 时就可以取出这个保存的数，就知道了需要释放内存的大小

### 24、malloc申请的存储空间能用delete释放吗

malloc /free的操作对象都是必须明确大小的。而且不能用在动态类上。new 和delete会自动进行类型和大小检查，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

### 25、malloc、realloc、calloc的区别

- malloc函数

  void* malloc(unsigned int num_size);

  int p = malloc(20*sizeof(int));申请20个int类型的空间；

- calloc函数

  void* calloc(size_t n,size_t size);

  int *p = calloc(20, sizeof(int));

  省去了人为空间计算；**malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的**；

- realloc函数

  void realloc(void *p, size_t new_size);

  给动态分配的空间分配额外的空间，用于扩充容量。

### 26、结构体变量比较是否相等

- 重载了 “==” 操作符

  ~~~c++
  struct foo {
      int a;
      int b;
      bool operator==(const foo& rhs) // 操作运算符重载
      {
          return( a == rhs.a) && (b == rhs.b);
      }
  };
  ~~~

- 元素的话，一个个比；
- 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；

### 27、函数调用过程栈的变化，返回值和参数变量哪个先入栈

从右向左依次把被调函数所需要的参数压入栈

### 28、怎样判断两个浮点数是否相等

**对两个浮点数判断大小是否相等不能直接用==来判断**，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！

~~~c++
if(abs(a-b)<0.00001) return true;
~~~

### 29、 宏定义一个取两个数中较大值的功能

~~~c++
#define MAX(x,y) (x>y?x:y)
~~~

### 30、define、const、typedef、inline使用方法

- **const与#define的区别**

  1)   const定义的常量是变量带类型，而#define定义的只是个常数不带类型；

  2)   define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；

  3)   define只是简单的字符串替换没有类型检查。而const有数据类型检查；

  4)   define定义占用代码段空间，const占用常量区空间； 

- **#define和别名typedef的区别**

  1）#define是宏定义，发生在预处理阶段，typedef发生在编译阶段

  2）typedef有类型检查的功能，#define没有

- **#define与inline的区别**

  1)   #define是关键字，inline是内联函数；

  2)   宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；

  3)   inline函数有类型检查，相比宏定义比较安全；

### 31、#include 的顺序以及尖括号和双引号的区别

- #include<>，表示编译器只在系统默认目录或尖括号内的工作目录下搜索头文件，并不去用户的工作目录下寻找，所以一般**尖括号用于包含标准库文件**；
- #include “ ”，表示**编译器**先在用户的工作目录下搜索头文件，如果搜索不到则到系统默认目录下去寻找，所以双引号一般用于包含**用户自己编写的头文件**。
- 搜索顺序：先自己后系统

### 32、lambda函数

- C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表达式具体形式如下:

  ~~~c++
  [capture](parameters)->return-type{body}//[外部变量访问方式说明符] (参数表) -> 返回值类型{语句块}
  [](int x, int y) -> int { int z = x + y; return z; }
  ~~~

- [capture]使用：

  ~~~c++
  []        //未定义变量.试图在Lambda内使用任何外部变量都是错误的
  [x, &y]   //x 按值捕获, y 按引用捕获
  [&]       //用到的任何外部变量都隐式按引用捕获
  [=]       //用到的任何外部变量都隐式按值捕获
  [&, x]    //x显式地按值捕获. 其它变量按引用捕获
  [=, &z]   //z按引用捕获. 其它变量按值捕获
  ~~~

- (parameters)->return -type{body}使用：

  ~~~c++
  [](int x, int y) { return x + y; } // 隐式返回类型
  [](int& x) { ++x; }   // 没有return语句 -> lambda 函数的返回类型是'void'
  []() { ++global_x; }  // 没有参数,仅访问某个全局变量
  []{ ++global_x; }     // 与上一个相同,省略了(）
  ~~~

- 举例

~~~c++
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int a[4] = { 1, 2, 3, 4 };
    int total = 0;
    for_each(a, a + 4, [&](int & x) { total += x; x *= 2; });
    cout << total << endl;  //输出 10
    for_each(a, a + 4, [=](int x) { cout << x << " "; });//输出 2 4 6 8
    return 0;
}
~~~

### 33、模板函数和模板类区别

- 函数模板

  表示的是一个模板，专门用来生产函数

  ~~~c++
  template<typename T>
  int func(T &a,T &b)
  {
      ...
  }
  ~~~

- 模板函数

  显式（explicitly）生产模板函数

  fun<int>、fun<double>、...

  隐式生产模板函数

  ~~~c++
  func(7);//隐式生成func<int>
  func(8.9);//隐式生成<double>
  ...
  ~~~

- 类模板

  表示的是一个模板，专门用于产生类的模子

  ~~~c++
  template<class T>
  class Vector
  {
      ...
  }
  ~~~

- 模板类

  只能显式调用类模板

  Vector<int>、Vector<char>...

- 区别

  函数模板允许显式和隐式调用，类模板只能显式调用

### 34、C++中类成员的访问权限和继承权限问题。

- 三种访问权限

  1）public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被  访问，在类外也是可以被访问的，是类对外提供的可访问接口；

  2）private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；

  3）protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。

- 三种继承方式

  1）若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；

  2）若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；

  3）若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。

### 35、cout和printf有什么区别？

- printf是函数，cout是ostream对象，和<<配合使用
- cout使用更方便：printf需要显式定义打印的格式，cout不需要，cout<<已存在针对各种类型数据的重载，所以会自动识别数据的类型。
- cout输出过程会首先将输出字符放入**缓冲区**，然后输出到屏幕。printf是**无缓冲输出**，有输出时立即输出

### 36、函数重载函数匹配原则

- 名字查找
- 确定候选函数
- 寻找最佳匹配

### 37、 定义和声明的区别

- 变量的声明和定义
   1）声明：从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。

  2）定义：定义就是分配了内存。

- 函数的声明和定义
   1）声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。
   2）定义：一般在源文件里，具体就是函数的实现过程 写明函数体。

### 38、C++类型转换有四种

- **static_cast静态类型转化**，能进行基础类型之间的转换，也是最常看到的类型转换。它主要有如下几种用法：

  1）进行上行转换（把子类的指针或引用转换成父类表示）是安全的；

  2）进行下行转换（把父类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的；

  3）用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

  4）把void指针转换成目标类型的指针（不安全！！）

  5）把任何类型的表达式转换成void类型。

- **const_cast**用于去除变量的常量性，用于**底层const** 

  const char* p=NULL; char *p1=const_cast<char *>(p); 。

- **reinterpret_cast 强制类型转化**。

- **dynamic_cast 动态类型转化**，主要用在继承体系中的安全**向下转型**。它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。转型失败会返回null（转型对象为指针时）或抛出异常bad_cast（转型对象为引用时）。 dynamic_cast 会动用运行时信息（RTTI）来进行**类型安全检查**，因此 dynamic_cast 存在一定的效率损失。

### 39、全局变量和static变量的区别

全局变量的说明之前再冠以static就构成了静态的全局变量

- 作用域不同：

  全局变量全局可见，static变量只在当前文件可见

- 存储方式：

  全局变量和static变量都存储于静态区（全局区）

### 40、 静态成员与普通成员的区别

- **生命周期**

  静态成员变量从类被加载开始到类被卸载，一直存在；

  普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；

-  **共享方式**

  静态成员变量是全类共享；普通成员变量是每个对象单独享用的；

- **定义位置**

  普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；

- **初始化位置**

  普通成员变量在类中初始化；静态成员变量在类外初始化；

- **默认实参**

  可以使用静态成员变量作为默认实参

### 41、隐式转换，如何消除隐式转换

- 隐式转换：是指不需要用户干预，编译器私下进行的类型转换行为
- 转换规则：隐式转换发生在从小->大的转换中（保证精度不丢失）。比如从char转换为int，从int->long，继承关系 子类对象可以隐式的转换为父类对象。
- C++中提供了**explicit关键字**，在**构造函数声明的时候加上explicit关键字**，能够禁止隐式转换
- 对于单参数的构造函数C++允许隐含的类型转换，容易破坏代码可读性，并导致难以发现的错误，通过关键字**explicit修饰构造函数可以禁止单参数构造函数创建隐式临时变量**。

### 42、迭代器++it,it++哪个好

- 前置返回一个引用

  ~~~c++
  // ++i实现代码为：
  int& operator++()
  {
      *this += 1;
      return *this;
  } 
  ~~~

- 后置返回一个对象

  ~~~c++
  //i++实现代码为：                                  
  int operator++(int)                                  
  {
  	int temp = *this;                                     
      ++*this;                                             
      return temp;                                    
  } 
  ~~~

​	前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低

### 43、c++异常处理机制

- c++中的异常情况：

  语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误

  运行时错误：比如数组下标越界、系统内存不足等等。C++中引入异常处理机制来解决此问题

- **C++异常处理机制**：try(检查)、throw(抛出)、catch(捕获)

  ~~~c++
  try 
  { 
  可能抛出异常的语句；（检查） 
  } 
  catch（类型名[形参名]）//捕获特定类型的异常 
  { 
  //处理1； 
  } 
  catch（类型名[形参名]）//捕获特定类型的异常 
  { 
  //处理2； 
  } 
  catch（…）//捕获所有类型的异常 
  { 
  }
  ~~~

### 44、在成员函数中调用delete this会出现什么问题

- 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。
- 如果在类的析构函数中调用delete this，会导致堆栈溢出。delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

### 45、动态联编与静态联编

- 静态联编是指联编工作在**编译阶段**完成的，其优点是效率高，但灵活性差。
- 动态联编是指联编在**程序运行时**动态地进行，根据当时的情况来确定调用哪个同名函数，优点是灵活性强，但效率低。C++中一般情况下的联编是静态联编，但是当涉及到多态时应该使用动态联编。

### 46、动态库和静态库区别（动态链接与静态链接的区别）

- **静态库（windows下为.lib，Linux下为.a）**在**链接阶段**，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，对应的链接方式为**静态链接**。

  优点：1）静态库对函数库的链接是放在编译时期完成的，程序在运行时与函数库再无联系，提高运行效率

  缺点：1）浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。2）如果静态库更新了，所使用它的应用程序需重新编译

- **动态库(window下为DLL,Linux下为.so)**在程序编译时不会被链接到目标文件，而是在**程序运行时**才被载入，对应的链接方式为**动态链接**。

  优点：动态库在程序运行时才被载入，解决了静态库更新带来的麻烦，缩小了执行文件本身的体积，加快了编译速度，节省了系统资源。

  缺点：1）需要附带一个相对庞大的链接库；2）如果其他计算机上没有安装对应的运行库，则用动态链接的可执行文件就不能运行。

### 47、在不使用额外空间的情况下，交换两个数？

- 算术

  ~~~c++
  x = x + y;
  y = x - y;
  x = x - y; 
  ~~~

-  异或

  ~~~c++
  x = x^y;// 只能对int,char..
  y = x^y;
  x = x^y;
  x ^= y ^= x;
  ~~~

### 48、strcpy、sprintf与memcpy的区别

- 操作对象不同

  strcpy的两个操作对象均为字符串 

  sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 

  memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

- 执行效率不同

  memcpy最高，strcpy次之，sprintf的效率最低

- 实现功能不同

  strcpy主要实现字符串变量间的拷贝 

  sprintf主要实现其他数据类型格式到字符串的转化 

  memcpy主要是内存块间的拷贝

### 49、volatile关键字的作用

- volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统，硬件，其它线程等）更改
- volatile关键字声明的变量，**防止编译器优化**，每次访问时都必须从内存中取出值（没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值）

### 50、 讲讲大端小端，如何检测

- 大端模式：是指数据的**高字节保存在内存的低地址**中，而数据的低字节保存在内存的高地址端。流采用大端字节序

- 小端模式，是指数据的**高字节保存在内存的高地址**中，低位字节保存在在内存的低地址端。一般情况位小端模式

- 判断：直接读取存放在内存中的十六进制数值，取低位进行值判断

  ~~~c++
  int a = 0x12345678;
  int *c = &a;
  c[0] == 0x12   //大端模式
  c[0] == 0x78   //小端模式
  ~~~

### 51、什么情况用指针当参数，什么时候用引用

- 使用引用参数的主要原因有两个：

  1）程序员能修改调用函数中的数据对象

  2）通过传递引用而不是整个数据–对象，可以提高程序的运行速度

- 一般的原则：

  如果数据是内置数据类型，则使用指针

  如果数据对象是数组，则只能使用指针

  如果数据对象是结构，则使用引用或者指针

  如果数据是类对象，则使用引用

### 52、sizeof 和strlen 的区别

- strlen计算字符串的具体长度（只能是字符串），不包括字符串结束符，返回的是字符个数。sizeof可以用类型做参数。
- sizeof计算声明后所占的内存数（字节大小），不是实际长度
- sizeof是一个取字节运算符，而strlen是个函数

### 53、 c++怎么实现一个函数先于main函数运行

如果在main函数之前声明一个**类的全局的对象**，**静态对象**。那么其执行顺序，根据全局对象/静态对象的生存期和作用域，肯定先于main函数

~~~c++
class simpleClass  
{  
public:  
       simpleClass( )  
       {  
              cout << "simpleClass constructor.." << endl;         
       }  
};     
simpleClass objectSimple;      
int main()   
{  
       return 0;  
} 
~~~

### 54、static_cast转换而不用c语言中的转换

- 更加安全；
- 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；
- 可读性更好，能体现程序员的意图

### 55、函数重载，重写

- **函数重载：**

  必须写在同一个类中
  子类无法重载父类的函数，父类同名函数将被覆盖
  重载是在编译期间根据参数类型和个数决定函数调用

- **函数重写：包括多态和重定义**
   必须发生于父类与子类之间，且父类和子类中的函数必须有完全相同的原型
   使用virtual声明后能够产生多态（如果不使用virtual，叫重定义）
   多态是在运行期间根据具体对象的类型决定函数调用

### 56、 C++新特性

- **auto**

  自动类型推导

- **lambda表达式**

  匿名函数，需要一个函数，又不想去命名一个函数的情况下使用

- **nullptr**

  取代NULL，专用于空指针，之前是这样定义的#define NULL 0

- **override**

  派生类显式的注明他将使用哪个成员函数改写基类的虚函数

  使用override好处：使得程序员的意图更加清晰，让编译器发现一些错误（未覆盖虚函数则报错），覆盖需要参数个数，类型以及返回值都相同

- **final**

  防止继承发生，在类名后面跟一个final关键字，则该类不能作为基类，在某个函数后加final，则派生类无法覆盖该函数

### 57、coredump

**什么是coredump**

​	程序由于各种异常或者bug导致在运行过程中异常退出或者中止，会产生一个叫做core的文件。

​        通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。

**Coredump产生原因**

- 函数栈溢出：（1）定义了一个体积太大的局部变量或参数，参数和局部变量都存储在栈中，但栈所占的内存空间很小，在32位下只有8M的空间。应使用malloc和new在堆上创建内存空间。（2）函数的嵌套调用层次太深，像无穷递归。
- 数组访问越界：最常见的问题
- 非法指针，空指针或野指针

### 58、常用信号

**命令产生信号**

9）SIGKILL 杀死进程

19）SIGSTOP信号，停止进程

9)和19）号信号，不允许忽略和捕捉，只能执行默认动作，是为了系统安全，保证系统有可靠的杀死进程和停止进程的机制。如：病毒感染系统，捕捉所有信号，将其处理方式该改为忽略，系统将崩溃。

**终端按键产生信号**

2）SIGINT 终止/中断 Ctrl+c

20）SIGTSTP 停止 Ctrl+z

3）SIGQUIT 退出 ctrl+\

**硬件异常产生信号**

11）SIGSEGV 段错误

7）SIGBUS总线错误

**软件条件产生信号**

14）SIGALRM信号，设置定时器，指定秒后，内核会给当前进程发送SIGALRM信号，动作终止

### 59、手写赋值运算符函数

- 先释放旧内存
- 根据t分配内存大小
- 用t赋值
- 注意返回值，应为类的引用

~~~c++
Example &Example::operator=(const Example &item)
{
    if (this->m_ptr != NULL)
    {
        delete[] m_ptr;
        m_ptr = NULL;
    }
    int len = strlen(item->m_ptr);
    this->m_ptr = new char[len + 1];
    strcpy(m_ptr,item->m_ptr);
    return *this;
} 
~~~

### 60、 空间计算，内存对齐

**空间计算**

- char ：1个字节
- char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）（16位机，32位机，64位机各不相同）
- short int : 2个字节
- int： 4个字节（16位机是2B，32位&64位是4B）
- unsigned int : 4个字节（16位机是2B,32位&64位是4B）
- float: 4个字节
- double: 8个字节
- long: 4个字节（16位&32位是4B，64位是8B）
- long long: 8个字节
- unsigned long: 4个字节（16&32位是4B,64位是8B）

**内存对齐**

- 为啥需要内存对齐

  1）平台原因(移植原因)-**方便移植**

  不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常

  2）性能原因：**方便内存访问**，提高存取数据的速度

  数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

- 内存对齐规则

  1）分配内存的顺序是按照声明的顺序。

  2）每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。

  3）最后整个结构体的大小必须是里面变量类型最大值的整数倍。

### 61、内存大小计算

**struct** 

~~~c++
struct MyStruct
{
    char dda;
    double dda1;
    int type;
}；
//这个结构占用的空间为多大呢？在VC6.0环境下，可以得到sizeof(MyStruc)为24。结合上面提到的分配空间的一些原则，分析下VC怎么样为上面的结构分配空间的。（简单说明）
struct MyStruct
{
    char dda; //偏移量为0，满足对齐方式，dda占用1个字节；
    double dda1; //下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。
    int type;//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。
};     //所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用
       //的字节数sizeof (double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。
~~~

所以该结构总的大小为：sizeof(MyStruc)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。

~~~c++
struct s1 {
    char a; 
    double b;
    int c;
    char d;
};                         //sizeof(s1)=24;
struct s2 {
    char a;
    char b;
    int c;
    double d;
};                      //sizeof(s2)=16;
~~~



struct s1 {

​    char a; 

​    double b;

​    int c;

​    char d;

};                         //sizeof(s1)=24;

struct s2 {

​    char a;

​    char b;

​    int c;

​    double d;

};                      //sizeof(s2)=16;

### 62、this指针

- **#1:this指针是什么时候创建的?**

  this在成员函数的开始执行前构造的，在成员的执行结束后清除。

- **#2:this指针存放在何处? 堆,栈,全局变量,还是其他?**

  this指针会因编译器不同，而放置的位置不同。可能是栈，也可能是寄存器，甚至全局变量。

- **#3:this指针如何传递给类中函数的?绑定?还是在函数参数的首参数就是this指针.那么this指针又是如何找到类实例后函数的?**

  this是通过函数参数的首参数来传递的。this指针是在调用之前生成的。类实例后的函数，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。

- **#4:this指针如何访问类中变量的/?**

  如果不是类，而是结构的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，那就很好理解这个问题了。

  在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了。

### 63、C++类型安全机制

C++不是类型安全的语言，但远比c更安全，提供了一些安全保障机制

- 用操作读new来申请内存，自动类型匹配，而malloc返回的是void*
- 提供dynamic_cast使得转换过程更安全，向下类型转换，其具有类型检查机制
- c中很多以void*为参数的函数可以改写成c++模板函数，而模板是支持类型检查的

### 64、虚函数可以声明inline吗

- 虚函数用于实现**运行**时的多态，或者称为晚绑定或动态绑定。
- 内联函数用于提高效率。内联函数的原理是，在**编译期间**，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用，可以减小函数调用的开销。但同时内敛函数会增加函数体积，不方便调试。
- 虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换，所以不能声明为内敛函数；

### 65、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些

- 类成员初始化方式：

  1)   赋值初始化，通过在函数体内进行赋值初始化；

  2）列表初始化，在冒号后使用初始化列表进行初始化

  3）区别：赋值初始化是在所有的数据成员被分配内存空间后才进行的，列表初始化是给数据成员分配内存空间时就进行初始化

- 构造函数的执行顺序 ：

  1）虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。

  2）基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。

  3）类类型的成员对象的构造函数（按照初始化顺序）

  4）派生类自己的构造函数。

- 用成员初始化列表会快一些： 
  赋值初始化是在构造函数当中做赋值的操作，而列表初始化是做纯粹的初始化操作。C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率。

### 66、成员列表初始化

- 必须使用成员初始化的三种情况：

  1） 当初始化一个引用成员或常量成员，因为引用和const对象只能初始化不能赋值，构造函数的体内只能做赋值而不是初始化，所以引用和const对象只能通过列表初始化。

  2）如果是继承关系，派生类必须在其初始化列表中调用基类的构造函数；

  3）如果含有类成员，需要在其初始化列表中调用成员类的构造函数；

- 成员初始化列表做了什么：

  1）编译时，**编译器**操作初始化列表，以适当的顺序在构造函数之前安插初始化操作

  2）初始化由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的

### 67、构造函数为什么不能为虚函数？析构函数为什么要虚函数？

### 68、构造函数的执行顺序？析构函数的执行顺序？

- 构造函数顺序

  1） 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

  2）成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

  3） 自身构造函数。

- 析构函数顺序

  1）调用自身的析构函数；

  2）调用成员类对象的析构函数；

  3）调用基类的析构函数。

### 69、父类的析构函数是否要设置为虚函数

 C++中基类采用virtual虚析构函数是为了**防止内存泄漏**。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

### 70、构造函数、析构函数可以调用虚函数吗

- 在构造函数和析构函数中最好不要调用虚函数；
- 构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别；
- 即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的。

### 71、构造函数析构函数可否抛出异常

C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用，因此会造成**内存泄漏**。

### 72、移动构造函数

- 设计初衷

  对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能**直接使用a的空间**呢？这样就避免了新的空间的分配，大大降低了构造的成本。

- 移动构造函数设计

  移动构造函数中，**对于指针采用浅层复制**。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将**第一个指针（比如a->value）置为NULL**，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；

  ~~~c++
  class Example
  {
  public:
  	Example(char *str)
  	{
          int len = strlen(str) + 1;
          data = new char[len];
          memset(data,0,len);
          strcpy(data,str);
  	}
  	Example(Example &s)//移动构造函数
  	{
          this->data = s.data;
          s.data = nullptr;
  	}
  	~Example()
  	{
          if(data != nullptr)
          {
              delete [] date;
          }
  	}
  private:
  	char *data;
  };
  
  int main()
  {
      char str[] = "It is a example";
      Example *a = new Example(str);
      Example *b = new Example(*a);
      delete a;
      cout<<"b对象中的字符串为："<<b->data<<endl;
      delete b;
      return 0;
  }
  ~~~

  

### 73、类如何实现只能静态分配和只能动态分配

- 建立类的对象有两种方式：

  1） 静态建立，静态建立一个类对象，就是由编译器为对象在**栈空间**中分配内存；

  2）动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在**堆空间**中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；

- 只能静态分配：把new、delete运算符重载为**private属性**。

- 只能动态分配：把构造、析构函数设为**protected属性**，再用子类来动态创建

- 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有。

### 74、什么情况会自动生成默认构造函数

- 如果一个类没有任何构造函数，但它含有一个**类成员对象**，且类成员对象有默认构造函数，那么编译器就为该类合成出一个默认构造函数。
- **带有默认构造函数的基类**，如果一个没有构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
-  **带有一个虚函数的类**，含有虚函数的类对象都含有**一个虚表指针vptr**，vptr在默认构造函数进行初始化。
- **带有一个虚基类的类**，子类对象中被合成一个指向虚基类的指针，因此也要被初始化，所以必须要构造函数

### 75、抽象类为什么不能创建对象

抽象类是一种特殊的类，它是为了抽象设计建立的，它处于继承层次结构的较上层。

- 抽象类的定义：
     称带有纯虚函数的类为抽象类。

  ~~~
  class <类名>
  {
  　　virtual int Function()= 0;
  };
  ~~~

- 抽象类作用：

  1）为了方便使用**多态**特性，我们常常需要在基类中定义虚拟函数。
  2）将有关的操作作为**接口**提供继承者使用。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

- 注意事项：

  抽象类是不能定义对象的

### 76、类什么时候会析构

- 对象**生命周期结束**，被销毁时；
- **调用delete**，或基类调用delete，而其基类虚构函数是虚函数时；
- **对象A是对象B的成员**，B的析构函数被调用时，对象A的析构函数也被调用。

### 77、C++多态

- **多态的实现效果**

  多态：同样的调用语句有多种不同的表现形态

- **多态分类**

  1）编译时多态

  利用函数重载，在编译的时候，就确定调用函数的类型。

  2）运行时多态

  在运行的时候，才确定调用的是哪个函数，动态绑定。

  条件：有继承，虚函数重写，有父类指针（引用）指向子类对象

- **多态的重要意义**

  设计模式的基础，是框架的基石。

- **多态原理探究**

  c++编译器提前布局的vptr指针，指向虚函数表，通过vptr指针找到虚函数表，找到函数入口地址，实现动态联编

### 78、继承机制中对象之间如何转换

- 向上类型转换

  将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。

- 向下类型转换

  将基类指针或引用转换为派生类指针或引用被称为向下类型转换，用**dynamic_cast**进行向下类型转换。

### 79、多继承的优缺点

- 多继承：派生类含有多个基类

- 优点：可以调用多个基类中的接口

- 缺点：派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。举例：如果访问a，就会出现**二义性**问题，到底是B中的a，还是C中的a

  ```c++
  class A {public:int a;};
  class B : public A{public:int b;};
  class C : public A{public:int C;};
  class D : public B, public C{};
  ```

  

  ![虚继承](F:\NOTE\C++开发总结\pic\虚继承.PNG)

  缺点解决方法：

  1）加上全局符确认调用，d.B::a，表明调用B中的a

  2）虚继承

  ```c++
  class A {public:int a;};
  class B : virtual public A{public:int b;};
  class C : virtual public A{public:int C;};
  class D : public B, public C{};
  ```

### 80、虚拟继承、多继承、普通继承区别

如果一个类中有虚函数，那么就会有一个虚表，有一个指针指向这个虚表。内存布局如下：

~~~c++
class A
{
public:
	virtual void funA();
}; 
~~~

![含有虚函数的类](F:\NOTE\C++开发总结\pic\含有虚函数的类.PNG)

普通继承：子类和父类各有一张虚函数表，子类虚函数表中继承的虚函数和自身的虚函数在一个虚表，自身虚函数地址在继承的虚函数之后，普通继承 B布局如下

~~~c++
class B : public A
{
public:
	virtual void funB();
}
~~~

![普通继承](F:\NOTE\C++开发总结\pic\普通继承.PNG)

多继承：子类中含有各基类指针和自身指针，子类中含有3种指针：父类A指针，父类B指针，自身指针。此时C的虚表有两个，分别如下：

虚表1：父类A虚表+派生类C自身虚表

虚表2：父类B虚表

~~~c++
class A
{
public:
	virtual void funA();
};  

class B
{
public:
	virtual void funB();
}

class C:public A,B
{
public:
	virtual void funC();
}
~~~

虚拟继承：子类中含有3种指针：自身vptr指针，基类vfptr指针，虚基类vbptr指针。

~~~c++
class A
{
public:
	virtual void funA();
};  

class B : virtual public A
{
public:
	virtual void funB();
}
~~~

![虚继承vptr](F:\NOTE\C++开发总结\pic\虚继承vptr.PNG)

内存计算：

~~~c++
//第一种情况 sizeof(a) = 4 sizeof(b) = 12
class a　　　　　　　　　
{　　　　　　　　　　　　
    virtual void func();
};　　　　　　　　　　　
class b:public virtual a
{　　　　　　　　　　　　
    virtual void foo();　
};　　　　　　　　　　　

//第二种情况 sizeof(a) = 4 sizeof(b) = 4
class a　　　　　　　　　　　
{　　　　　　　　　　　　　　
　　　　virtual void func();
 };　　　　　　　　　　　　　
　class b :public a　　　　　
{　　　　　　　　　　　　　　
　　　  virtual void foo();　
 };　　　　　　　　　　　　　　　　　　　　　　　　　

//第三种情况 sizeof(a) = 8 sizeof(b) = 16
class a　　　　　　　　　
{　　　　　　　　　　　　
　　 virtual void func();
　　 char x;　　　　　　　
};　　　　　　　　　　　　
class b:public virtual a　
{　　　　　　　　　　
	virtual void foo();
};　　　　　　　　　　　　

//第四种情况 sizeof(a) = 8 sizeof(b) = 8
　class a
　{
　　　virtual void func()
　　  char x;
  };
 class b:public a
 {
　　　virtual void foo();
 };

//第五种情况 sizeof(a) = 4 sizeof(b) = 4 sizeof(c) = 12
　class a
　{
　　　virtual void func()
  };
 class b
 {
　　　virtual void foo();
 };
 class c:public a,b
 {
　　　virtual void fooc();
 };
~~~

### 81、空类会默认添加哪些东西？怎么写？

```c++
1)	Empty(); // 默认构造函数
2)	Empty( const Empty& ); // 拷贝构造函数
为什么需要const：因为防止传入参数被修改
为什么是传引用：避免无限递归的发生
3)	~Empty(); // 析构函数
4)	Empty& operator=( const Empty& ); // 赋值运算符
```

### 82、为什么拷贝构造函数必须传引用不能传值

 拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。

### 83、空类的大小是多少

c++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配**1字节大小**，这样便保证了每个实例均有独一无二的内存地址。

### 84、设计一个类计算子类的个数

- 为类设计一个static静态变量count作为计数器；
- 类定义结束后初始化count;
- 在构造函数中对count进行+1;
- 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；
- 设计复制构造函数，在进行复制函数中对count+1操作；
- 在析构函数中对count进行-1

### 85、虚函数的代价？

- 带有虚函数的类，**每一个类会产生一个虚函数表**，用来存储指向虚成员函数的指针，增大类；
- 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
- 不能再是内敛的函数，因为内敛函数在编译阶段进行替代，而虚函数在运行阶段才能确定采用哪种函数，虚函数不能是内敛函数。

### 86、类对象的大小

- 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
- 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
- 虚函数的话，会在类对象插入vptr指针，加上指针大小；
- 当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。
- 多继承：每一个基类都涉及一个虚函数表，会增加一个vfptr指针指向虚函数表vfTable，所占空间大小为：4（或4乘以多继承时父类的个数）
- 虚承继：由于涉及到虚函数表和虚基表，会同时增加一个（**多重虚继承下对应多个**）vfPtr指针指向虚函数表vfTable和一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）

### 87、 哪些函数不能是虚函数

- 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，**虚表指针在构造函数中初始化**；
- 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
- 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
- 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
- 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

### 88、C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？

- 阻止一个类被实例化：将类定义为**抽象基类**或者将**构造函数声明为private**；
- 什么时候将构造函数声明为private：不允许类外部创建类对象，只能在类内部创建对象

### 89、虚函数与纯虚函数的区别在于

- 纯虚函数只有定义没有实现，虚函数既有定义又有实现；
- 含有纯虚函数的类不能定义对象，含有虚函数的类能定义对象；

### 90、C语言宏定义中的#,##,#@及\符号的作用

1） # （stringizing）字符串化操作符

~~~c++
#define example(instr) printf("the input string is:\t%s\n",#instr)//example(abc); 在编译时将会展开成：printf("the input string is:\t%s\n","abc");
#define example1(instr) #instr//string str=example1(abc); 在编译时将会展成：string str="abc";
~~~

2） #@ （charizing）字符化操作符

将传入单字符参数名转换成字符，以一对单引用括起来

~~~c++
#define makechar(x)  #@x//char a = makechar(b);在编译时将会展成：char a=''b';
~~~

3）## （token-pasting）符号连接操作符

将宏定义的多个形参转换成一个实际参数名

~~~c++
#define exampleNum(n) num##n//int num=exampleNum(9); 将会扩展成 int num=num9;
~~~

4）\ 续行操作符

 当定义的宏不能用一行表达完整时，可以用""表示下一行继续此宏的定义。注意\前留空格

### 91、vim基本操作

~~~
set nu    显示行号
gg     跳转到文件开头
/     向后搜索
?    向前搜索
n    查找下一处
N    查找上一处
|     光标所在行行首
L    屏幕所显示的底行
{    段首
}    段尾
-    前一行行首
+    后一行行首
(    句首
)    下一句首
$    行末
M    屏幕中间行
0    行首（零）
hjkl    左下上右
x    删除光标所在字符
R    替换模式（可以替换任意字符）
r    单个替换
dd     删除光标所在的行
D    删除至行末（从光标位置开始）
s    删除字符并插入（单个字符删除，并进入插入模式）
S    删除行并插入（整行删除）
>>     缩进（相当于一个tab）
<<     反缩进
=    自动格式化
J    合并上下两行
I    插入到行首
i     插入
C    从光标处开始修改至行位
a    在光标后附件或追加
A    在行末追加
p    粘贴（后）
P    粘贴（前）
Esc     命令模式
ZZ     保存退出编辑(vi，含保存)
ZQ    不保存退出编辑
~~~

## 二、C++11

### 1、auto类型推导

- auto自动类型推导发生在编译器，自动推断出变量的类型

- 适用场景：

  for循环

  模板类

- 禁用场景：

  不能用于函数参数

  不能用于非静态成员变量

  无法定义数组

  无法推导出模板参数
  
  ~~~
  auto i = 10;//auto类型为int
  ~~~

### 2、decltype关键字

- 编译时推导出一个表达式的类型，格式：

  ~~~
  decltype(exp)
  ~~~

- 用法：

  ~~~c++
  int a;
  decltype(a) b = 1;
  ~~~

### 3、返回类型后置语法

- 后置语法是auto和decltype结合使用
- 用法：

~~~c++
template<typename T, typename U>
auto add(T t,U u)->decltype(t+u)
{
	return u+t;
}
~~~

### 4、模板的别名（using使用）

- 模板定义

  ~~~c++
  template<typename T>
  struct str_map
  {
  	typedef std::map<std::string, T> type;
  }
  str_map<int>::type map1;
  ~~~

- c++11简化写法

  ~~~c++
  template<typename T>
  using str_map_t = std::map<std::string, T>;
  str_map_t<int> map1;
  ~~~

### 5、列表初始化

- new操作符等可用圆括号或初始化列表进行初始化

  ~~~c++
  int *a = new int{20};
  ~~~

- 堆上分配的数组可用初始化列表初始化

  ~~~c++
  int *arr = new int[3]{1,2,3};
  ~~~

### 6、范围for循环

- vector

  ~~~c++
  vector<int> a{1,2,3,4};
  for(auto i: a)
  {
  	cout<<i<<endl;
  }
  ~~~

- map

  ~~~c++
  map<string,int> mp{{"a",1},{"b",2},{"c",3}};
  for(auto val: mp)
  {
  	cout<<val.first<<"->"val.second<<endl;
  }
  ~~~

### 7、std::function

std::function是可调用对象的包装器。

使用说明

~~~c++
#include<functional>//头文件
#include<iostream>
class T
{
    std::function<void(void)> mCallback;
public:
    T(const std::function<void(void)> &f): mCallback(f){}
    
    void notify()
    {
        mCallback();//回调到上一层
    }
};
void Func(void)
{
    std::cout<<"this a test program"<<std::endl;
}

int main()
{
    T t(Func);
    t.notify();
    return 0;
}
~~~

### 8、std::bind绑定器

std::bind用来将可调用对象与其参数一起进行绑定。绑定结果可以使用std::function进行保存

~~~c++
#include<functional>//头文件
#include<iostream>
void do_when(int a,std::function<void(int)> f)
{
    if(a%2==0){
        f(a);
    }
}
void output(int a)
{
    std::cout<<"output： "<<a<<std::endl;
}
void output2(int a)
{
    std::cout<<"output2： "<<a+2<<std::endl;
}

int main()
{
    vector<int> vec{1,2,3,4,5,6,7,8,9};
    auto f = std::bind(output,std::placeholders::_1);//std::placeholders::_1表示传入的第一个参数
    f(110);//输出output：110 
    for(auto i: vec)
    {
        do_when(i, f);
    }
    auto f2 = std::bind(output2,std::placeholders::_1);
    f2(120);
    for(auto i: vec)
    {
        do_when(i, f2);
    }
    std::bind(output2,std::placeholders::_1)(12);//输出output2：14 
    return 0;
}
~~~

### 9、lambda表达式

lambda表达式价值：封装短小的功能闭包，让上下文结合得更加紧密

~~~c++
[capture](params)opt->ret{body;};
//capture捕获列表：1、[]不捕获任何变量2、[=]捕获外部所有变量，且按值捕获3、[&]捕获外部所有变量，且按引用捕获4、[a]捕获指定变量a，且按值捕获5、[this]捕获类中this指针
//params参数表
//opt函数选项
//ret返回值类型
//body函数体
~~~

~~~
auto s = [](int a){return a;};
auto s1 = [&]{return a+b};
auto s2 = [&]{return a++};
auto s3 = [=]{return a};
~~~

### 10、tuple元祖

tuple元祖类似于结构体，tuple适用于3个以内的结构体，可简化代码

~~~c++
tuple<char*,int, int*>tp;
char *a = tp.get<0>();//获取第一个值
int k = tp.get<1>();//获取第二个值
~~~

### 11、右值引用

- c++11中所有值必属于左值、将亡值、纯右值。将亡值和纯右值属于右值。
- 左值与右值区分：可对表达式用&符取址，则为左值，否则为右值。
- 右值引用主要用于支持移动语义。

### 12、move语义

主要用于移动构造，将左值转换为右值，避免对临时对象的深拷贝，提高性能

~~~c++
class A
{
public:
	A(){};
	A(const A& a):m_ptr(new int(*a.m_ptr)){};//拷贝构造函数，深拷贝
	A(A &&a): m_ptr(a.m_ptr){
        a.m_ptr = nullptr;
    };//移动构造函数，浅拷贝
    ~A(){delete m_ptr;};
private:
	int *m_ptr;
};
~~~

### 13、emplace_back使用

emplace_back能就地通过参数构造对象，不需要拷贝或者移动拷贝，相比push_back 能更好地避免内存的拷贝和移动，提高插入元素的性能。

日常使用中尽量使用emplace/emplace_back代替insert/push_back。

~~~c++
struct A{
	int a;
	double b;
	A(int x,double y):a(x),b(y){}
}
int main
{
	vector<A> vec;
    vec.emplace_back(1,2.3);
}
~~~

### 14、unordered_map

map和set内部是红黑树，元素会自动排序

unordered_map内部是hash table，元素是无序的，效率更高

### 15、线程

~~~c++
#include<thread>
void func()
{

}
int main()
{
	std::thread p(func);//c++11线程创建
    p.detach();//detach线程和线程对象分离，让线程作为后台线程去执行，p.join函数将阻塞线程
    return 0;
}
~~~

### 16、互斥量

~~~c++
#include<iostream>
#include <thread>
#include <mutex>

int a = 10;
std::mutex mutex;//c++11提供的独占互斥量，简化mutex创建方法
void func()
{
    //c++11中lock_guard可简化lock/unlock的写法，lock_guard在构造时会自动锁定互斥量，退出作用域后进行析构时会自动解锁
	std::lock_guard<std::mutex> lock(mutex);
    a++;
}
int main()
{
    std::thread p1(func);
    p1.detach();
    std::thread p2(func);
    p2.detach();
    return 0;
}
~~~

### 17、条件变量

条件变量用于线程同步

c++11提供condition_variable，配合std::unique_lock< std::mutex >进行wait操作

condition_variable_any，和任意带lock、unlock语义的mutex使用，效率低于condition_variable

条件变量使用：

1）拥有条件变量的线程获取互斥量

2）循环检查某个条件，如果条件不满足，则阻塞等待条件满足；如果条件满足，则向下执行

3）某个线程满足条件执行完任务后调用notify_one获notify_all唤醒一个获所有等待的线程

### 18、原子变量

c++11提供原子类型std::atomic<T>，使用原子变量就不需要互斥量来保护该变量，使用更简洁

### 19、chrono库

chrono库提供duration、clocks和time point来实现timer

### 20、数值类型转字符串

to_string方法可将各种数值类型转为字符串类型

~~~c++
auto f = 1.23;
std::string ptr = to_string(f);
auto f1 = 12;
std::string ptr1 = to_string(f1);
~~~

## 三、数据结构

### 1、vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素

- vector数据结构
   vector和**数组类似**，拥有一段**连续的内存空间**，并且起始地址不变。因此能高效的进行随机存取，中间插入和删除效率低 

- list数据结构
   list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取效率低，但能高效地进行插入和删除。

- 访问倒数第二个元素

  vector: int mySize = vec.size();vec.at(mySize -2);

  list: list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历：

### 2、数组和vector区别

- 内存中的位置

  C++中数组为内置的数据类型，存放在**栈**中，其内存的分配和释放完全由系统自动完成；vector，存放在**堆**中，由STL库中程序负责内存的分配和释放，使用方便。

- 大小能否变化

  数组的大小在初始化后就固定不变，而vector的长度可以通过push_back或pop等操作而发生变化。

- 初始化

  数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而vector可以。

- 执行效率

  数组>vector。主要原因是vector的扩容过程要消耗大量的时间。

### 3、STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？如何释放空间？

- vector的实现

  1）vector和数组类似，拥有一段连续的内存空间，能高效的进行随机存取，中间插入和删除效率低。

  2）vector中size（）表示**已用空间**大小，capacity（）表示**总的空间**大小，当size()==capacity()时，vector的空间会动态增长，重新建一个vector容器，新分配的空间大小为原来的2倍，然后将原vector容器的内容拷贝至新容器。

- 两倍扩容

  不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍； 空间分配的多，平摊时间复杂度低，但浪费空间也多。采用成倍方式扩容，可以保证时间复杂度为常数，因此，使用成倍的方式扩容。

- vector初始化

  1）vector.reserve()增加了vector的capacity，但是它的size没有改变！

  2）vector.resize()改变了vector的capacity同时也增加了它的size,默认插入元素为0；

- 删除元素

  pop_back()，从尾端对元素进行删除，也可以用erase进行区间删除，或用clear清除所有元素，但是这几种删除只是删除了元素，但并没有释放元素所占用的空间，通过swap()可以用来释放空间，或用shrink_to_fit()缩小空间

- swap()使用

  //用法：vector<int>(v).swap(v)

  ~~~c++
  vector<int>().swap(v)
  {
      std::vector<int> temp(v);
      temp.swap(v);
  }
  ~~~

  通过该语句，可以将v中空闲的空间释放掉，该语句包含vector(v) 和 .swap(v) 两部分，vector(v)通过拷贝构造函数创建匿名对象，这个匿名对象拥有v的全部数据，但是，没有空闲的空间，也就是说，这个匿名对象的 容量 和 数据量 是相等的。

- ~~~c++
  vector<int> v(10,5);
  std::cout<<"v 数据量"<<v.size()<<std::endl;//size 10
  vector<int>().swap(v);
  std::cout<<"v 数据量"<<v.size()<<std::endl;//size 0
  ~~~


### 4、set与hash_set区别/map与hashmap区别

- set/map底层是以RB-Tree实现，hash_set/hashmap底层是以hash_table实现的；
- RB-Tree有自动排序功能，而hash_table不具有自动排序功能；

### 5、HashMap、HashTable、ConcurrentHashMap区别

- **HashTable**：

  底层数组+链表实现，无论key还是value都**不能为null**，线程**安全，**实现线程安全的方式是在修改数据时锁住整个HashTable，效率低。ConcurrentHashMap做了相关优化，采用分段锁的设计，只有在同一个分段内才存在竞争关系，提高了高并发环境下的处理能力。

- **HashMap**：

  1）**实现**：底层数组+链表实现，是Hashtable的轻量级实现，可以**存储null键和null值**，线程**不安全**

  2）**不安全原因：**HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用**拉链法解决碰撞冲突**。多线程访问时，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点， 那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失

  3）**什么时候扩容：**hash_table的表格元素为桶元素，使用vector容器存放桶元素，主要是因为vector容器本身具有动态扩容能力，无需人工干预，当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值（一般为数组大小的75%）---即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。将创建原来大小的两倍的数组，并将原来的对象放进新的数组中，删除之前所占的内存。

- **ConcurrentHashMap**：

  底层采用分段的数组+链表实现，线程**安全**

### 6、hashmap与hashtable区别

- HashMap是非线程安全的，HashTable是线程安全的。
- HashMap的键和值都允许有null值存在，而HashTable则不行。
- 因为线程安全的问题，HashMap效率比HashTable的要高，HashTable修改数据时需要锁住整个HashTable
- Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。

### 7、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？

- 他们的底层都是以**红黑树**的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除；
- 定义了一个**函数模版**，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value
- 因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。

### 8、map插入方式有几种？

- 用insert函数插入**pair数据**

  mapStudent.insert(pair<int, string>(1,"student_one"));

- 用insert函数插入**value_type数据**

  mapStudent.insert(map<int, string>::value_type(1, "student_one"));

- 在insert函数中使用**make_pair()函数**

  mapStudent.insert(make_pair(1, "student_one"));  

- 用**数组**方式插入数据

  mapStudent[1] = "student_one";

### 9、vector越界访问下标，map越界访问下标

- 访问vector中的元素时首先进行边界检查，可以使用vector中的at函数。通过使用at函数不但可以通过下标访问vector中的元素，而且在at函数内部会对下标进行边界检查
- 将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的值插入这个map

### 10、基本数据结构总结

- vector 底层数据结构为数组 ，支持快速随机访问
- list 底层数据结构为双向链表，支持快速增删
- deque 是一个双端队列，支持首尾（中间不能）快速增删，也支持随机访问
- stack底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
- queue底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
- priority_queue 优先队列的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
- set 底层数据结构为红黑树，有序，不重复
- multiset  底层数据结构为红黑树，有序，可重复 
- map  底层数据结构为红黑树，有序，不重复
- multimap 底层数据结构为红黑树，有序，可重复
- hash_set  底层数据结构为hash表，无序，不重复
- hash_multiset 底层数据结构为hash表，无序，可重复 
- hash_map 底层数据结构为hash表，无序，不重复
- hash_multimap 底层数据结构为hash表，无序，可重复 

### 11、STL六大组件

- 容器（Container）
- 算法（Algorithm）
- 迭代器（Iterator）
- 仿函数（Function object）
- 适配器（Adaptor）
- 空间配置器（allocator）

## 四、操作系统

### 1、操作系统特点

并发性、共享性、虚拟性、不确定性。

### 2、进程

- 进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程；
- 进程是系统进行资源分配的最小单位，且每个进程拥有独立的地址空间
- 进程有运行、阻塞、就绪，停止四个基本状态；
- **进程调度算法**：先来先服务调度算法、短作业优先调度算法、非抢占式优先级调度算法、抢占式优先级调度算法、高响应比优先调度算法、时间片轮转法调度算法；

### 3、父，子进程的区别

通过fork产生的父子进程，**子进程是父进程的完整副本，**实际上是采用**写时复制**技术，在需要修改全局变量时，才会拷贝父进程的（0-3g）空间，目的是为了提高程序运行效率

- **相同点**

  （0-3G虚拟地址空间）：全局变量，代码段，堆，栈，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式。

- **不同点**

  进程ID，fork返回值，父进程ID，进程运行时间

### 4、fork和vfork区别

- 通过vfork创建的进程时不复制父进程的地址空间，共享父进程的代码以及数据段（0-3G）
- 在定义一个全局变量，父进程对变量进行自加操作，vfork产生的子进程中变量值为自加后的值，而fork产生的父子进程将互不影响

### 5、进程状态转换图​         ![进程状态转换图](F:\NOTE\C++开发总结\pic\进程状态转换图.png)                 

1)   新建态：进程已经创建

2)   就绪态：进程做好了准备，准备执行，等待分配处理机

3)   运行态：该进程正在执行；

4)   阻塞态：等待某事件发生才能执行，如等待I/O完成；

5)   终止状态

就绪->运行：获得处理机

运行->就绪：时间片用完或有更高优先级的进程就绪

运行->阻塞：当进程请求某一资源的使用和分配或等待某一事件的发生（如等待I/O操作的完成）,会从运行态转为阻塞态

阻塞->就绪：当进行等待的事件到来时，如I/O操作结束或中断结束

### 6、进程与线程的区别

- 进程含有独立的地址空间，而线程共享地址空间；
- 线程是轻量级的进程，最小执行单位。进程为最小分配资源的单位。
- 进程切换，消耗的资源大。所以涉及到频繁的切换，使用线程要好于进程；
- 两者均可并发执行；

### 7、进程与作业的区别

- 作业是应用层面的概念，和任务类似，如统计数据并打印而实施的一系列技术性操作
- 进程仅仅是操作系统层面的概念，是一系列资源，如cpu时隙，内存，硬盘，句柄等的集合，在进程里面可能跑有一些线程，这些线程依赖这些资源，完成一系列或一个技术性操作
- 一个作业可由多个进程组成，且必须至少由一个进程组成

### 8、 线程共享的资源是什么？

线程私有：线程ID，线程栈，信号屏蔽字，调度优先级 

共享：内存地址空间（.text/.data/.bss/heap/共享库）（无stack栈），文件描述符，每个信号的处理方式

### 9、  什么时候用多进程？什么时候用多线程？

-  需要频繁创建销毁的优先用线程；
- 需要进行大量计算的优先使用线程；
- 强相关的处理用线程，弱相关的处理用进程；
- 可能要扩展到多机分布的用进程，多核分布的用线程；
- 需要更稳定安全时，适合选择进程

### 10、协程

- 比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；
- 协程的开销远远小于线程
- 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源
- 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型；
- 协程又称为微线程，协程的完成主要靠yeild关键字
- 不需要多线程的锁机制

### 11、fork详解

函数原型

~~~c++
pid_t fork(void); //void代表没有任何形式参数
~~~

除了0号进程（系统创建的）之外，linux系统中都是由其他进程创建的。

~~~c++
int pid=fork();
if(pid < 0){
    //失败，一般是该用户的进程数达到限制或者内存被用光了   
    ........     
}
else if(pid == 0){
    //子进程执行的代码
    ......
}
else{
    //父进程执行的代码，fork函数返回新建子进程的pid
    .........
}
~~~

### 12、死锁是什么？必要条件？如何解决？

概念：相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态

- **产生原因：**

  系统资源不足

  相互竞争资源，线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁

  请求资源顺序不当

- **必要条件：**

  互斥条件：一个资源每次只能被一个进程使用。

  请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

  不可抢占条件: 进程已获得的资源，在末使用完之前，不能强行剥夺，只能在进程使用完时由自己释放。

  循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。

- **如何避免：**

  加锁顺序；

  加锁时限：对一个互斥量加锁后，使用了共享资源便立即释放锁，便可避免死锁

  死锁检测：线程1拥有A锁，请求获得B锁，此时使用trylock函数，如果无法获得B锁，则放弃已有的A锁

  银行家算法；

- **怎么处理：**因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：剥夺资源、杀死其中一个线程

### 13、递归锁

Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。

### 14、鸵鸟策略

当系统发生死锁时不会对用户造成多大影响，或系统很少发生死锁的场合，并且出现之后处理死锁会花费很大的代价，则采用鸵鸟算法，即死锁发生置之不理

### 15、银行家算法

系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。

银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配

### 16、进程间通信方式有几种，他们之间的区别是什么？

- **管道（PIPE，无名管道）**

  半双工的，具有固定的读端和写端；

  只能用于具有亲属关系的进程之间的通信；

  可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write函数。但是它不是普通的文件，并不属于其他任何文件系统，只能用于内存中。

  Int pipe(int fd[2]);当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。

- **FiFO（有名管道）**

  FIFO可以在无关的进程之间交换数据，与无名管道不同；

- **消息队列**

  消息队列，是消息的连接表，存放在内核中。一个消息队列由一个标识符来标识；

  消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；

  消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；

  消息队列可以实现消息的随机查询

- **信号量**

  信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；

   **信号量用于进程间同步，若要在进程间传递数据需要结合共享内存**；

  信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作；

- **共享内存**

  共享内存，指**两个或多个进程共享一个给定的存储区**；

  共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取；

  因为多个进程可以同时操作，所以需要进行同步；

### 17、线程间通信

- **锁机制**

  互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。

  读写锁：允许多个线程同时读共享数据，而对写操作互斥。

  条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用。

- **信号量机制**：包括无名线程信号量与有名线程信号量

- **信号机制**：类似于进程间的信号处理。

  线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。

### 18、页和段的区别

- 页是信息的物理单位，分页是由于系统管理的需要。段是信息的逻辑单位，分段是为了满足用户的要求。
- 页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序。
- **分页的作业的地址空间是一维的**，程序员只需要利用一个记忆符，即可表示一个地址。**分段的作业地址空间则是二维的**，程序员在标识一个地址时，既需要给出段名，又需要给出段的地址值。

### 19、 孤儿进程和僵尸进程的区别？怎么避免这两类进程？守护进程？

**孤儿进程**：父进程结束，子进程仍在运行，父进程未将子进程回收，此时子进程称为孤儿进程，由init进程领养

解决：父进程先结束会调用 wait 或者 waitpid 函数等待子进程完成再退出

 **僵尸进程**：子进程结束，父进程仍在运行，父进程没有对子进程进行回收，子进程残留资源（pcb）存放在内核中，成为僵尸进程

解决:子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。

 **守护进程**（ daemon) 是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务 。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。

### 20、守护进程

- 通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程的名字**一般以d结尾**

- 守护进程是个**特殊的孤儿进程**，这种进程脱离终端，**为什么要脱离终端呢？**之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。

- 守护进程特点：

  ![守护进程](F:\NOTE\C++开发总结\pic\守护进程.PNG)

  守护进程基本上都是以超级用户启动（ UID 为 0 ）

  没有控制终端（ TTY 为 ？）

  终端进程组 ID 为 -1 （ TPGID 表示终端进程组 ID）

- 实现

  1）屏蔽一些控制终端操作的信号

  这是为了防止守护进行在没有运行起来前，控制终端受到干扰退出或挂起

  2）在后台运行

  这是为避免挂起控制终端将守护进程放入后台执行。方法是在进程中调用 fork() 使父进程终止， 让守护进行在子进程中后台执行。

  3）脱离控制终端、登录会话和进程组

  调用 setsid() 使子进程成为新的会话组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。

  4）禁止进程重新打开控制终端

  进程已经成为无终端的会话组长，**但它可以重新申请打开一个控制终端**。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端，采用的方法是再次创建一个子进程

  5）关闭打开的文件描述符

  进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误

  6）改变当前工作目录

  进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。

  7）重设文件创建掩模

  程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取权限。为防止这一点，将文件创建掩模清除

  8）处理 SIGCHLD 信号

  处理僵尸进程

  ~~~c++
  #include <unistd.h> 
  #include <signal.h> 
  #include <fcntl.h>
  #include <sys/syslog.h>
  #include <sys/param.h> 
  #include <sys/types.h> 
  #include <sys/stat.h> 
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
   
  int init_daemon(void)
  { 
  	int pid; 
  	int i;
  	// 1）屏蔽一些控制终端操作的信号
  	signal(SIGTTOU,SIG_IGN); 
  	signal(SIGTTIN,SIG_IGN); 
  	signal(SIGTSTP,SIG_IGN); 
  	signal(SIGHUP ,SIG_IGN);
  	// 2）在后台运行
      if( pid=fork() ){ // 父进程
          exit(0); //结束父进程，子进程继续
  	}else if(pid< 0){ // 出错
  		perror("fork");
  		exit(EXIT_FAILURE);
      }
  	// 3）脱离控制终端、登录会话和进程组
  	setsid();  
  	// 4）禁止进程重新打开控制终端
  	if( pid=fork() ){ // 父进程
  		exit(0);      // 结束第一子进程，第二子进程继续（第二子进程不再是会话组长） 
  	}else if(pid< 0){ // 出错
  		perror("fork");
  		exit(EXIT_FAILURE);
  	}  
  	// 5）关闭打开的文件描述符
  	// NOFILE 为 <sys/param.h> 的宏定义
  	// NOFILE 为文件描述符最大个数，不同系统有不同限制
  	for(i=0; i< NOFILE; ++i){
  		close(i);
  	}
  	// 6）改变当前工作目录
  	chdir("/");	
  	// 7）重设文件创建掩模
  	umask(0);  
  	// 8）处理 SIGCHLD 信号
  	signal(SIGCHLD,SIG_IGN);	
  	return 0; 
  } 
   
  int main(int argc, char *argv[]) 
  {
  	init_daemon();
  	while(1);
  	return 0;
  }
  ~~~

  结果：

  ![守护进程实现](F:\NOTE\C++开发总结\pic\守护进程实现.PNG)

### 21、用户态到内核态的转化原理

- 系统调用

  这是用户态进程主动要求切换到内核态的一种方式

- 异常

  当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

- 外围设备的中断

  当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。比如硬盘读写操作完成

### 22、用户态和内核态的区别

- 内核态与用户态是操作系统的两种运行级别
- 当程序运行在**3级**特权级上时，就可以称之为运行在**用户态**，这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；
- 当程序运行在**0级**特权级上时，就可以称之为运行在**内核态**。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 
- 差别： 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的 ； 而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。 

### 23、 执行一个系统调用时，OS发生的过程

- 执行用户程序(如:fork) 
- 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断
- 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）
-  进行中断处理，根据系统调用表调用内核函数。
-  执行内核函数。
- 执行RESTORE_ALL并返回用户模式

### 24、函数调用和系统调用的区别

- 系统调用

  操作系统提供给用户程序调用的一组特殊的接口。用户程序可以通过这组特殊接口来获得操作系统内核提供的服务；

  进行软件中断处理，调用内核函数

-   函数调用

  函数调用运行在用户空间；

  它主要是通过压栈操作来进行函数调用；

![函数调用和系统调用](F:\NOTE\C++开发总结\pic\函数调用和系统调用.png)

### 25、经典线程同步问题：1）生产者与消费者问题

- 思路

  生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费，显然生产者和消费者之间必须保持同步，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个已经放入产品的缓冲区中再次投放产品。

- 方案

  1）基于**队列**构建一个缓冲区，生产者在队尾填充，消费者在队头获取。队列缓冲区作为多个线程的共享资源。

  2）由于多个消费者和生产者线程可以并发访问缓冲区，需要**互斥锁来控制对缓冲区的互斥访问**。

  3）队列空时消费者线程需要等到队列中存在资源、队列满时生产者线程需要等到队列中有资源被消费。通过使用**条件变量来实现线程的阻塞、通知，实现生产、消费线程的同步**。

### 26、虚拟内存？使用虚拟内存的优点？什么是虚拟地址空间

- 虚拟内存，虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上
- 优点：可以弥补物理内存大小的不足；一定程度的提高反应速度；
- 缺点：占用一定的物理硬盘空间；加大了对硬盘的读写

### 27、常见的IO模型，五种？ 

- **1)**   **阻塞I/O**

  **应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好**。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。

- **2)**   **非阻塞I/O**

  我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。

- **3)   I/O复用**

  I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这三个函数可以**同时阻塞多个I/O操作**。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。

- **4)**   **信号驱动I/O**

  首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

- **5)**   **异步I/O**

  当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。

### 28、IO复用的原理

IO复用是Linux中的IO模型之一，IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通知进程处理，从而不会在单个IO上阻塞了。Linux中，提供了select、poll、epoll三种接口函数来实现IO复用。

- select

  1） 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。

  2）由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；

  3）内核/用户空间内存拷贝问题，select需要大量句柄数据结构，产生巨大开销；

  4）Select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么每次select调用还会将这些文件描述符通知进程。

- Poll

  与select相比，poll使用**链表**保存文件描述符，没有了监视文件数量的限制，但其他三个缺点依然存在

-   Epoll

  上面所说的select缺点在epoll上不复存在，epoll使用**一个文件描述符管理多个描述符**，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

  Epoll是**事件触发**的，不是轮询查询的。没有最大的并发连接限制，内存拷贝，利用mmap（）文件映射内存加速与内核空间的消息传递。

-  区别总结：

  1)   文件描述符数量限制

  Select最大1024个连接，Poll，Epoll没有最大连接限制

  2）FD剧增后带来的IO效率问题

  select， Poll因为每次进行线性遍历，所以随着FD的增加会造成遍历速度下降，效率降低；epool内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback。

  3)   消息传递方式

  Select， Poll内核需要将消息传递到用户空间，都需要内核拷贝；Epoll通过内核和用户空间共享来实现的。

###  29、epoll 的 LT 和 ET 模式的理解

epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)，LT是默认模式。

- LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
- ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

### 30、Linux如何避免内存碎片

- **伙伴系统**
- 按可移动性组织页，避免内存碎片

### 31、页面置换算法

操作系统将内存按照页的进行管理，在需要的时候才把进程相应的部分调入内存。当产生缺页中断时，需要选择一个页面写入。如果要换出的页面在内存中被修改过，变成了“脏”页面，那就需要先写会到磁盘。页面置换算法，就是要选出最合适的一个页面，使得置换的效率最高

- 最优页面置换算法

  最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面

- 最近未使用页面置换算法（NRU）

- 先进先出页面置换算法（FIFO）

  这种算法的思想和队列是一样的，OS维护一个当前在内存中的所有页面的链表，最新进入的页面在尾部，最久的在头部，每当发生缺页中断，就替换掉表头的页面并且把新调入的页面加入到链表末尾。

- 时钟页面置换算法（clock）

- 最近最少使用页面置换算法（LRU）

  缺页中断发生时，置换未使用时间最长的页面，称为LRU

### 32、内存管理方式

 常见的内存管理方式有**块式管理、页式管理、段式管理和段页式管理**。最**常见的是段页式管理**。

段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一数据，要访问3次内存

### 33、内存五区

- **栈区**

  栈区(stack)由**编译器**自动分配并释放，存放的是函数的参数值，局部变量等，方法调用的实参也是保存在栈区的。主要存放一些基本类型的变量和对象引用类型。

- **堆区**

  由程序员分配和释放，如果程序员不释放，可能会出现内存泄露。主要存放用new构造的对象和数组。

- **全局区(静态区)**

  全局变量和静态变量是放在一起的，初始化的全局变量和静态变量存放在一块区域（.data），未初始化的全局变量和静态变量在相邻的另一块区域(.bss)，程序结束后由系统释放。

- **常量区** 

  存放常量字符串，程序结束后由系统释放。

- **代码区**

  存放函数的二进制代码

### 34、I/O控制方式

- **直接I/O（轮询）**

  程序查询方式也称为程序轮询方式，该方式采用用户程序直接控制主机与外部设备之间输入/输出操作。

- **中断**

  当I/O设备结束(完成、特殊或异常)时，就会向CPU发出中断请求信号，CPU收到信号就可以采取相应措施。

- **DMA**

  DMA方式也称为直接主存存取方式，其思想是：允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预。

- **通道**

- 通道(Channel)也称为外围设备处理器、输入输出处理机，是相对于CPU而言的。

### 35、共享内存的实现

- 共享内存就是允许两个不相关的进程访问同一个内存
- 不同进程之间共享的内存通常安排为同一段物理内存，进程A可以即时看到进程B对共享内存中数据的更新，反之亦然
- 通过互斥锁和信号量，实现进程同步
- 共享内存是两个正在运行的进程之间共享和传递数据的最有效的方式

### 36、线程池，内存池

- 为什么需要线程池

  频繁创建线程和销毁线程，系统开销大，尤其是线程执行的时间非常非常短的情况

- 线程池原理

  在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。

- 线程池的使用场景

  需要大量的线程来完成任务，且完成任务的时间比较短；对性能要求苛刻的应用；

### 37、内存池

- 内存池的原理

  在软件开发中，有些对象使用非常频繁，那么我们可以预先**在堆中实例化一些对象**，我们把维护这些对象的结构叫“内存池”。在需要用的时候，直接从内存池中拿，而不用从新实例化，在要销毁的时候，不是直接free/delete，而是返还给内存池。把那些常用的对象存在内存池中，就不用频繁的分配/回收内存，可以相对**减少内存碎片**，更重要的是实例化这样的对象更快，回收也更快。当内存池中的对象不够用的时候就扩容。

- 内存池的优缺点

  内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。

### 38、 accept调用, 系统是如何维护已连接队列的

- 多客户端如何创建连接

  在使用accept函数的时候，如果服务器面向多个客户的连接，必须使用**while循环，每次循环阻塞在accept函数，等待新的连接到来，这样才能返回新的socket**。

  ~~~c++
  while(1){
  	socket  s = ss.accept();
  }
  ~~~

- 如何维护已连接客户端

  必须使用**数组（或其他数据结构）保存当前accept创建的socket**，否则下次新的socket建立后，当前的socket将不受控制。

### 39、 内存和硬盘的存储速度那个快

- 内存存储速率更快
- 内存，一般分为RAM、ROM和高速缓存三大类。
  硬盘，一般分为机械硬盘和固态硬盘。固态硬盘使用的是闪存，比机械硬盘的磁盘要快得多，但也不能和真正的RAM去比速度。
- 它们的存储原理和读取方式不一样。
  硬盘是有**机械结构**的，磁头要运动到相应的位置，转片还在转动，然后读取磁信号。而内存是电，瞬间到达。

### 40、 Wait和waitpid的区别

- wait会令调用者**阻塞**直至某个子进程终止；

- waitpid则可以通过设置一个选项来设置为**非阻塞**，另外waitpid可以等待参数中**pid指定的进程**。

- **waitpid**中pid的含义依据其具体值而变：

  pid==-1 等待任何一个子进程，此时waitpid的作用与wait相同

  pid >0   等待进程ID与pid值相同的子进程

  pid==0   等待与调用者进程组ID相同的任意子进程

  pid<-1   等待进程组ID与pid绝对值相等的任意子进程

### 41、C++三个线程循环打印ABC

使用C++11的标准线程语法创建线程，用一个int型标志位变量控制**条件变量**的wait()阻塞等待时机（当标志位为0时，A线程打印A,设置标志位为1，当标志位为1时，B线程打印B，设置标志位为2，当标志位为2时，C线程打印C，设置标志位为0），用**notify_all()唤醒条件变量**。

当 std::condition_variable对象的某个wait 函数被调用的时候，它使用 **std::unique_lock(通过 std::mutex) 来锁住当前线程**。当前线程会一直被阻塞，直到另外一个线程在相同的std::condition_variable 对象上调用了**notify_all()**函数来唤醒当前线程。

~~~c++
#include <iostream>
#include <thread>
#include <condition_variable>

std::mutex mtx;//互斥锁
std::condition_variable cv;//条件变量
int ready = 0;//标志位，0打印A,1打印B，2打印C
void PrintString_1()
{
	std::unique_lock<std::mutex> lk(mtx);
	int cnt = 0;
	while (cnt<10)//循环打印10次
	{
		while (ready != 0)
			cv.wait(lk);//阻塞等待，标志位为0
		std::cout << std::this_thread::get_id() << " : " << "A" << std::endl;
		ready = 1;//设置标志位为1，打印B
		cnt++;
		cv.notify_all();//唤醒所有线程
	}
}

void PrintString_2()
{
	std::unique_lock<std::mutex> lk(mtx);
	int cnt = 0;
	while (cnt<10)
	{
		while (ready != 1)
			cv.wait(lk);
		std::cout << std::this_thread::get_id() << " : " << "B" << std::endl;
		ready = 2;
		cnt++;
		cv.notify_all();
	}
}

void PrintString_3()
{
	std::unique_lock<std::mutex> lk(mtx);
	int cnt = 0;
	while (cnt<10)
	{
		while (ready != 2)
			cv.wait(lk);
		std::cout << std::this_thread::get_id() << " : " << "C" << std::endl;
		ready = 0;
		cnt++;
		cv.notify_all();
	}
}

int main()
{
	std::thread  t1(PrintString_1);//c++11 标准线程
	std::thread  t2(PrintString_2);
	std::thread  t3(PrintString_3);
	t1.join();//阻塞等待线程退出
	t2.join();
	t3.join();
	return 0;
}
~~~

结果：

![循环打印ABC](F:\NOTE\C++开发总结\pic\循环打印ABC.png)

## 五、计算机网络

## 六、算法

## 七、数据库

### 1、事务是什么

事务（txn）是一系列在共享数据库上执行的行为，以达到更高层次更复杂逻辑的功能。事务是DBMS中最基础的单位，事务不可分割。

**ACID**，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：**原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）**。

- 原子性是指**事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生**。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- 一致性是指**事务使得系统从一个一致的状态转换到另一个一致状态。**这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
- 隔离性指**多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果**。
- 持久性，意味着在**事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中**，并不会被回滚。

### 2、一二三范式

- 第一范式：字段值具有原子性，不能再分（所有关系型数据库系统都满足第一范式）**字段不可拆分**

  例如：姓名字段，其中姓和名是一个整体，部分拆分

- 第二范式：一个表必须有主键，即每行数据都能被唯一的区分；前提：必须满足第一范式

  **有主键，非主键字段依赖主键**

- 第三范式：**一个表中不能包含其他相关表中非关键字段的信息**，即数据表不能有冗余字段提前：必须满足第二范式

  **非主键字段不能相互依赖**

### 3、数据库的索引类型，数据库索引的作用

数据库索引好比是一本书前面的目录，能加快数据库的查询速度。

- 优点：

  大大加快数据的检索速度;

- 缺点：

  索引需要占用数据表以外的物理存储空间；创建索引和维护索引要花费一定的时间；

- 类型

  唯一索引——UNIQUE

  主键索引——primary key

  聚集索引（也叫聚簇索引）——cluster

- 实现方式

  B+树、散列索引、位图索引

### 4、聚集索引和非聚集索引的区别

- 聚集索引表示表中存储的数据按照**索引的顺序存储**，检索效率比非聚集索引高，但对数据更新影响较大。
- 非聚集索引表示**数据存储在一个地方，索引存储在另一个地方**，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。
- 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。

### 5、唯一性索引和主键索引的区别

- 唯一索引：如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引
- 主键索引：必须为主键字段创建一个索引，这个索引就是所谓的“主索引
- 主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是PRIMARY而不是UNIQUE

### 6、数据库引擎，innodb和myisam的特点与区别

最新版本MySQL默认是InnoDB;

- 事务处理：

  MyISAM不支持事务处理，InnoDB支持事务处理；

- 锁机制不同：

  MyISAM是表级锁（不支持高并发，以读为主），而InnoDB是行级锁（共享锁，排它锁，意向锁）；

- select ,update ,insert ,delete 操作：

  MyISAM：如果执行大量的SELECT，MyISAM是更好的选择

  InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表

- 外键支持：

  MyISAM表不支持外键，而InnoDB支持

### 7、关系型和非关系型数据库区别

关系型数据库：SQLite、Oracle、mysql

- 特性：

  采用关系模型来组织的数据库

  具有事务的一致性

- 优点：

  容易理解：关系型数据库中的表为二维表结构

  使用方便：可使用SQL语言操作关系型数据库

  易于维护：丰富的完整性降低了数据冗余和数据不一致的概率

- 缺点：

  固定的表结构

  高并发读写效率低

  海量数据读写效率低

非关系型数据库：MongoDB、redis、HBase

- 特性：

  使用键值对存储数据

  分布式

  不支持ACID

- 优点：

  无需经过sql层的解析，读写性能好

  基于键值对存储，数据之间没有耦合关系，容易扩展

  存储数据格式多样化：可为文档、图片等

- 缺点：

  不提供sql语言操作数据库

### 8、数据库的隔离级别

隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数据库可靠性低，但并发量高，系统开销小。

- READ UNCIMMITTED（未提交读），事务中的修改，即使没有提交，其他事务也可以看得到，会产生**脏读**
- READ COMMITTED（提交读），大多数数据库系统的默认隔离级别是READ COMMITTED，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。
- REPEATABLE READ（可重复读），REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题**幻读**。
- SERIALIZABLE（可串行化），SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况。

### 9、脏读，幻读

- 脏读，事务的修改，即使没有提交，其他事务也可以看得到
- 幻读，某事务在读取某个范围的数据，而另一个事务正在向这个范围中插入数据，导致多次读取时，获得数据不一致

### 10、 数据库连接池的作用

-  在内部对象池中，维护一定数量的数据库连接。
- 资源重用，由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。
- 更快的系统响应速度。
- 统一的连接管理，避免数据库连接泄露，较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用的连接，从而避免了常规数据库连接操作中可能出现的资源泄露。

### 11、数据的锁的种类，加锁的方式

**锁**是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。数据库锁出现的目的：处理并发问题；

- 锁的种类：乐观锁、悲观锁。

- 悲观锁：读锁，写锁

  每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。**对数据操作前加锁**

- 乐观锁

  每次去拿数据的时候都认为别人不会修改，所以不会上锁。乐观锁适用于多读的应用类型，这样可以提高吞吐量。**对数据操作前不加锁**

## 八、设计模式

## 九、Bash基础

### 1、标准输入、输出与标准错误输出

| **文件描述符** | **名称** | **通用缩写** | **默认值** |
| -------------- | -------- | ------------ | ---------- |
| 0              | 标准输入 | stdin        | 键盘       |
| 1              | 标准输出 | stdout       | 屏幕       |
| 2              | 标准错误 | stderr       | 屏幕       |

#### 1.1 输出重定向 

| 语法   | 说明                                                   |
| ------ | ------------------------------------------------------ |
| >      | 把标准输出重定向到一个新文件，”>” 会覆盖原有的内容。   |
| >>     | 把标准输出重定向到一个文件中，不覆盖原有的内容(追加)。 |
| 2 >    | 把标准错误重定向到一个文件中                           |
| 2 >>   | 把标准错误重定向到一个文件中(追加)                     |
| 2 > &1 | 把标准输出和错误重定向到一个文件(追加)                 |

#### 1.2 输入重定向

| 语法         | 说明                                      |
| ------------ | ----------------------------------------- |
| <            | filename文件作为标准输入                  |
| << delimiter | 从标准输入中读入，知道遇到delimiter分界符 |

#### 1.3 绑定重定向

| **语法** | **说明**                        |
| -------- | ------------------------------- |
| > &m     | 把标准输出重定向到文件描述符m中 |
| < &-     | 关闭标准输入                    |
| > &-     | 关闭标准输出                    |

### 2、变量

#### 2.1 环境变量

通过使用printenv可以显示当前的环境变量

~~~shell
[root@IDC-D-1699 ~]# printenv
HOSTNAME=IDC-D-1699
TERM=xterm
SHELL=/bin/bash
HISTSIZE=1000
SSH_CLIENT=111.200.23.36 31752 22
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/3
USER=root
MAIL=/var/spool/mail/root
PATH=/usr/local/java/jdk1.8.0_101/bin:/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
JAVA_HOME=/usr/local/java/jdk1.8.0_101
LANG=zh_CN.UTF-8
HISTCONTROL=ignoredups
SHLVL=1
HOME=/root
LOGNAME=root
~~~

使用$可获取变量名称

~~~shell
[root@IDC-D-1699 ~]# a=$PWD;echo $a
/root
[root@IDC-D-1699 ~]# a=$PATH;echo $a
/usr/local/java/jdk1.8.0_101/bin:/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
~~~

通过``符号和$()也可以执行Linux命令并获取运行结果

~~~shell
[root@IDC-D-1699 ~]# a=`pwd`;echo $a
/root
[root@IDC-D-1699 ~]# a=$(pwd);echo $a
/root
[root@IDC-D-1699 ~]# a=`path`;echo $a
/usr/local/java/jdk1.8.0_101/bin:/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
~~~

#### 2.2 本地变量

Shell不需要明确定义类型，事实上Shell变量的值都是字符串，比如我们定义var=45，其实var的值是字符串而非整数，shell变量不需要事先定义就可以使用，如果使用没有定义的变量，这字符串取值为空字符串。

变量名称=”变量Value”，“=”的两边不能有空格，否则shell解释成名称和命令参数。

获取变量使用 $变量名称

~~~shell
[root@IDC-D-1699 ~]# a="abc";echo $a
abc
~~~

##### 2.2.1 内容代换

可以使用*、?、[]对内容代换

| **匹配符** | **说明**                           |
| ---------- | ---------------------------------- |
| *          | 匹配0个多个任意字符                |
| ?          | 匹配一个任意字符                   |
| []         | 匹配方括号中任意一个字符的一次出现 |

##### 2.2.2 命令代换

将命令替换为命令输出，所有的shell支持使用反引号的方式进行命令替换，命令替换可以嵌套，需要注意的是如果使用反引号的形式，在内部反引用前必须使用反斜杠转移

| **匹配符** | **说明**        |
| ---------- | --------------- |
| ``         | 例如echo `pwd`  |
| $()        | 例如echo $(pwd) |

##### 2.2.3 算术代换

| **匹配符** | **说明**             |
| ---------- | -------------------- |
| $(())      | 例如 echo $((4 + 6)) |

### 3、符号

#### 3.1 转义字符

'\’用作转义字符

#### 3.2 单引号

单引号内的所有字符都保持它本身字符的意思，而不会被bash进行解释

#### 3.3 双引号

除了$、``、/外，双引号内所有的字符保持字符本身的含义

### 4、逻辑判断

#### 4.1 if

在shell中用if，then，elif，else，fi这几条命令实现分支控制，这种流程控制语句本质上也是由若干个逻辑判断组成，需要注意的是

- if/then结束都离不开fi
- if和[]注意用空格隔开，]后面紧跟;
- []内的条件与都有一个空格隔开

~~~shell
if [ -f $a ];then 
        echo "hello world!" 
fi
~~~

#### 4.2 case

case结构用于多种情况的条件判断，类似于其它语言的switch/case，但从语法结构上有很大的不同，常用格式

~~~shell
case 字符串 in
    模式)
        语句
        ;;
    模式2 | 模式3)
         语句
        ;;
    *)
     默认执行的 语句
         ;;
esac
~~~

~~~shell
#!/bin/bash
read -p "请输入要查查询的区号:" num
case $num in
 
   *)echo -n "中国";;&
     03*)echo -n "河南省";;&
        ??71)echo "郑州市";;
        ??72)echo "安阳市";;
        ??73)echo "新乡市";;
        ??73)echo "许昌市";;
     07*)echo -n "江西省";;&
        ??91)echo "南昌市";;
        ??92)echo "九江市";;
        ??97)echo "赣州市";;
esac
~~~

注意

当程序指定到条件语句;;&时，不会停止，直到执行到;;esac

不管是if还是case，他们的结尾都很有意思，if的结尾是fi，而case的结尾是easc，首位和尾部正好相反

### 5、循环

#### 5.1 for

~~~shell
#!/bin/bash
for i in $(ls); do
    echo item: $i
done
~~~

#### 5.2 while

~~~shell
#!/bin/bash
num=$1
while [ $num -le 20 ];do
	echo num:$num
	num=$(($num+1))
done
~~~

#### 5.3 until

~~~shell
#!/bin/bash
num=$1
until [ $num -lt 20 ];do
	echo num:$num
	let num=num-1
done
~~~

### 6、比较运算

#### 6.1 比较符

| **比较符**      | **说明**                            | **举例**               |
| --------------- | ----------------------------------- | ---------------------- |
| -e filename     | 如果filename存在，则为真            | [ -e /var/log/syslog ] |
| -d filename     | 如果filename为目录，则为真          | [ -d /tmp/mydir ]      |
| -f filename     | 如果filename常规文件，则为真        | [ -f /usr/bin/grep ]   |
| -L filename     | 如果filename为符号链接，则为真      | [ –L /usr/bin/grep ]   |
| -r filename     | 如果filename可读，则为真            | [ –r /var/log/syslog ] |
| -w filename     | 如果filename可写，则为真            | [ –w /varmytmp.txt ]   |
| -x filename     | 如果filename可执行，则为真          | [ –x /usr/bin/grep ]   |
| -s filename     | 如果filename不是空白文件，则为真    |                        |
| -u filename     | 如果filename有SUID属性，则为真      |                        |
| -g filename     | 如果filename有SGID属性，则为真      |                        |
| -k filename     | 如果filename有stickybit属性，则为真 |                        |
| file1 –nt file2 | 如果file1比file2新，则为真          |                        |
| file1 –ot file2 | 如果file1比file2旧，则为真          |                        |

#### 6.2 字符串比较运算符

| **比较符**   | **说明**                     |
| ------------ | ---------------------------- |
| -z string    | 如果string长度为零，则为真   |
| -n string    | 如果string长度不为零，则为真 |
| str1 = str2  | 如果str1与str2相同，则为真   |
| str1 != str2 | 如果str1与str2不相同，则为真 |

#### 6.3 算数比较符

| **比较符** | **说明**   |
| ---------- | ---------- |
| -eq        | 等于       |
| -ne        | 不等于     |
| -lt        | 小于       |
| -le        | 小于或等于 |
| -gt        | 大于       |
| -ge        | 大于或等于 |

## 十、cmake基础

