

# C语言

## （1）传值

### 传值的过程：

（1）行参与实参各占一个独立的存储空间。

（2）行参的存储空间是函数被调用时才分配的。调用开始，系统为行参开辟一个临时

存储区，然后将各实参之值传递给行参，这时行参就得到了实参的值。

（3）函数返回时，临时存储区也被撤销。

传值的特点：单向传递，即函数中对行参变量的操作不会影响到调用函数中的实参变量。

**例1：**

\#include<stdio.h>  

void myswap(int x, int y)  

{  

    int t;  

    t=x;  

    x=y;  

    y=t;  

}  

int main()  

{  

    int a, b;  

    printf("请输入待交换的两个整数：");  

    scanf("%d %d", &a, &b);  

    myswap(a,b);  //作为对比，直接交换两个整数，显然不行  

    printf("调用交换函数后的结果是：%d 和 %d\n", a, b);  

    return 0;  

}

**结果:**

输入2 3，输出2 3

**解析：**

传值不成功的原因是指在形参上改变了数值，没有在实参上改变数值。

## （2）传址

就是传变量的地址赋给函数里形式参数的指针，使指针指向真实的变量的地址，因为对指针所指地址的内容的改变能反映到函数外，也就是能改变函数外的变量的值。

**例2：**

\#include<stdio.h>  

void myswap(int *p1, int *p2)  

{  

    int  t;  

    t=*p1;  

    *p1=*p2;  

    *p2=t;  

}  

int main()  

{  

    int a, b;  

    printf("请输入待交换的两个整数：");  

    scanf("%d %d", &a, &b);  

    myswap(&a,&b);  //交换两个整数的地址  

    printf("调用交换函数后的结果是：%d 和 %d\n", a, b);  

    return 0;  

}

**结果：** 

输入2 3，输出3 2

**解析：**

传地址成功的原因利用指针改变了原来的地址，所以实参就交换了。



# C++

## （1）传值：同上

## （2）传地址：同上

## （3）传引用

实际是通过指针来实现的，能达到使用的效果如传址，可是使用方式如传值。

**例3：**

\#include<stdio.h>  

void myswap(int &x, int &y)  

{  

    int t;  

    t=x;  

    x=y;  

    y=t;  

}  

  int main()  

{  

    int a, b;  

    printf("请输入待交换的两个整数：");  

    scanf("%d %d", &a, &b);  

    myswap(a,b);  //直接以变量a和b作为实参交换  

    printf("调用交换函数后的结果是：%d 和 %d\n", a, b);  

    return 0;  

}  

**结果：**

输入2 3，输出3 2

**解析：**

引用是直接改变两个实参变量a，b的值，所以就交换了。

## 建议：

如果传值的话，会生成新的对象，花费时间和空间，而在退出函数的时候，又会销毁该对象，花费时间和空间。

因而如果int，char等固有类型，而是你自己定义的类或结构等，都建议传指针或引用，因为他们不会创建新的对象。

**内存分配方式:**

此外还应注意内存的分配方式,内存分配方式有三种：

（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的

整个运行期间都存在。例如全局变量，static 变量。

（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函

数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集

中，效率很高，但是分配的内存容量有限。

（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意

多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存

期由我们决定，使用非常灵活，但问题也最多。