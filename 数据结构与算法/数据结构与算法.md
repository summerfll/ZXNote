



# 数据结构与算法

## 1.导论

数据结构是研究数据元素与元素之间得关系（表，栈，队列。。。）

### 1.1 数据的逻辑结构

![数据结构1](F:\学习专用\note\pic\数据结构1.png)

### 1.2 算法复杂度

**大O表示法：**

算法效率依赖于操作数量

在判断时首先关注操作数量的最高次项

![数据结构2](F:\学习专用\note\pic\数据结构2.png)

操作数量的估算可以作为时间复杂度的估算

![数据结构3](F:\学习专用\note\pic\数据结构3.png)

~~~C++
#include<iostream>
using namespace std;
//时间复杂度
//每个指令在具体的计算机cpu上运行的时间是固定的
//通过具体的n的步骤的多少就可以推算出算法的复杂度

//空间复杂度
//程序所需的内存空间
void play01(int n)//2n+4==>n无穷大时，复杂度O(n)  //空间复杂度 4n+12 ==>O(n)
{
	long sum=0;//1 //4
	int *array = (int *)malloc(sizeof(int)*n);//1 //4*n
	for (int i = 0;i < n;i++)//n //4 含int i;
	{
		array[i] = i+1;
	}
	for (int i = 0;i < n;i++)//n //4
	{
		sum += array[i];
	}
	cout << sum << endl;//1 //0
	free(array);//1 //0
}
void play02(int n)//n+2==>n无穷大时，复杂度O(n)//空间复杂度 8 ==>O(1)
{
	long sum=0;//1 //4
	for (int i = 0;i < n;i++)//n //4
	{
		sum += i+1;
	}
	cout << sum << endl;//1 //0
}
void play03(int n)//2==>n无穷大时，复杂度O(1)//空间复杂度 4 ==>O(1)
{
	long sum=0;//1 //4
	if (n > 0)
	{
		cout << (1 + n)*n / 2 << endl;//1 //0
	}
}
void main()
{
	play01(9);
	play02(9);
	play03(9);
	system("pause");
}
~~~

### 1.3 空间换时间思想

~~~c++
#include<iostream>
#include<map>
using namespace std;
/*
计算一个由自然数1-1000组成的数组中，出现次数最多的数字
*/
void play(int *array,int len)
{
	int tmp[1000] = { 0 };//事先分配一个内存空间用于缓存每个数出现的次数，在缓存的结果中求最大值
	int max = 0;
	for (int i = 0;i < len;i++)//将出现次数放在下标位置-1处
	{
		int index = array[i] - 1;
		tmp[index]++;
	}
	for (int i=0;i<sizeof(tmp)/sizeof(tmp[0]);i++)//找出数组中出现最多的次数
	{
		if (max<tmp[i])
		{
			max = tmp[i];
		}
	}
	for (int i = 0;i<sizeof(tmp) / sizeof(tmp[0]);i++)//找到最多次对应的数字
	{
		if (max==tmp[i])
		{
			cout << "出现最多次数的数字是： " << i + 1 << endl;
		}
	}
	
}
void play02(int *array,int len,map<int,int> m)
{
	int max = 0;
	for (int i = 0;i < len;i++)//将值和次数放进map中
	{
		pair<map<int, int>::iterator, bool> pair1 = m.insert(make_pair(array[i], 1));
		if (pair1.second==false)
		{
			m[array[i]]++;
		}
	}
	for (map<int,int>::iterator it=m.begin();it!=m.end();it++)
	{
		if (max<(it->second))
		{
			max = it->second;
		}
	}
	for (map<int, int>::iterator it = m.begin();it != m.end();it++)
	{
		if (max==(it->second))
		{
			cout << it->first;
		}
	}
}
void main()
{
	int array[] = {1,4,56,7,54,2,3,2,1,2,2,2,2,2,2,22,3,6,6,64,5,56,4,4,6,6,6,6};
	int l = sizeof(array) / sizeof(array[0]);
	play(array,l);
	map<int, int> m;
	play02(array,l,m);
	system("pause");
}
~~~

## 2. 线性表设计与实现

**线性表的操作**

创建线性表

销毁线性表

清空线性表

将元素插入线性表

将元素从线性表中删除

获取线性表中某个位置的元素

获取线性表的长度

### 2.1 线性表顺序存储

#### 2.1.1设计与实现

**插入元素：**

- 判断线性表是否合法
- 判断线性表容量是否已满
- 将插入位置后的所有元素后移（从最后一个元素开始）
- 插入元素到指定位置
- 线性表长度加1

**获取元素：**

- 判断线性表是否合法
- 判断位置是否合法
- 通过数组下标的方式获取元素

**删除元素：**

- 判断线性表是否合法
- 判断删除位置是否合法
- 将删除位置后的所有元素前移（从删除元素的下一个元素开始）
- 线性表长度减1

#### 2.1.2 案例实现（c）

~~~c++
//seqlist.h
#pragma once
#include<iostream>
using namespace std;
typedef void SeqList;
typedef void SeqListNode;

typedef struct tag_SeqList
{
	int len;
	int capacity;
	unsigned int *node;//int *node[]
}TSeqList;
//创建线性表
SeqList *SeqList_Create(int capacity);
//销毁线性表
void SeqList_Destroy(SeqList *list);
//清空链表 
void SeqList_Clear(SeqList *list);
//链表长度
int SeqList_Length(SeqList *list);
//链表容量
int SeqList_Capacity(SeqList *list);
//将元素插入线性表
int SeqList_Insert(SeqList *list, SeqListNode *node, int position);
//获取线性表中某个位置的元素
SeqListNode *SeqList_Get(SeqList *list, int position);
//删除元素
SeqListNode* SeqList_Delete(SeqList *list, int position);
~~~

~~~c++
//seqlist.cpp
#pragma once
#include<iostream>
using namespace std;
#include"seqlist.h"
//创建链表
SeqList *SeqList_Create(int capacity)
{
	int ret = 0;
	TSeqList *tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret = -1;
		cout << "func SeqList_Create() err : " << ret << endl;
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));
	//根据capacity分配节点空间
	tmp->node = (unsigned int *)malloc(sizeof(unsigned int *)*capacity);
	if (tmp->node == NULL)
	{
		ret = -2;
		cout << "func SeqList_Create() err : " << ret << endl;
		return NULL;
	}
	tmp->capacity = capacity;
	tmp->len = 0;
	return tmp;
}
//销毁链表
void SeqList_Destroy(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TSeqList *)list;
	if (tlist->node != NULL)
	{
		free(tlist->node);
	}
	free(tlist);
}
//清空链表 
void SeqList_Clear(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TSeqList *)list;
	tlist->len = 0;
}
//链表长度
int SeqList_Length(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->len;
}
//链表容量
int SeqList_Capacity(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->capacity;
}
//插入元素 ！！！！！！！！！！！！
int SeqList_Insert(SeqList *list, SeqListNode *node, int position)
{
	int ret = 0;
	int i = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || node == NULL || position<0)
	{
		ret = -1;
		cout << "func SeqList_Insert() err: " << ret << endl;
		return ret;
	}
	tlist = (TSeqList *)list;
	//判断容量是否已满
	if (tlist->capacity <= tlist->len)
	{
		ret = -2;
		cout << "func SeqList_Insert() err (tlist->capacity <= tlist->len) err : " << ret << endl;
		return ret;
	}
	//容器修正，长度为6 容量20 用户插入位置为10
	if (position >= tlist->len)
	{
		position = tlist->len;
	}
	//元素后移
	for (i = tlist->len; i > position; i--)
	{
		tlist->node[i] = tlist->node[i - 1];//tlist->node[i]为最后一个元素的下一个位置
	}
	//插入元素
	tlist->node[i] = (unsigned int)node;
	tlist->len++;
}
SeqListNode *SeqList_Get(SeqList *list, int position)
{
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || position < 0)
	{
		cout << "func SeqList_Get() err : " << endl;
		return NULL;
	}
	tlist = (TSeqList *)list;
	ret = (void *)tlist->node[position];
	return ret;
}
//删除元素 ！！！！！！！！！！！
SeqListNode* SeqList_Delete(SeqList *list, int position)
{
	int i = 0;
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || position < 0)
	{
		cout << "func SeqList_Delete() err : " << endl;
		return NULL;
	}
	tlist = (TSeqList *)list;
	ret = (void *)tlist->node[position];
	//元素前移
	for (i = position;i < tlist->len;i++)//从position位置后面的元素前移
	{
		tlist->node[i] = tlist->node[i + 1];
	}
	tlist->len--;
	return ret;
}
~~~

~~~c++
//test.cpp
#include<iostream>
using namespace std;
#include"seqlist.h"
struct student
{
	student(int i)
	{
		age = i;
	}
	int age;
};
void main()
{
	SeqList *list = NULL;
	student s1(10), s2(20), s3(30);
	list = SeqList_Create(10);
	SeqList_Capacity(list);
	SeqList_Length(list);
	SeqList_Insert(list,(SeqListNode *)&s1,0);//头插法
	SeqList_Insert(list, (SeqListNode *)&s2, 0);
	SeqList_Insert(list, (SeqListNode *)&s3, 0);
	for (int i=0;i<SeqList_Length(list);i++)
	{
		student *tmp = (student *)SeqList_Get(list,i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	cout << "------------------" << endl;
	//删除链表中的头节点
	SeqList_Delete(list,0);
	for (int i = 0;i<SeqList_Length(list);i++)
	{
		student *tmp = (student *)SeqList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	SeqList_Clear(list);//删除链表中的所有元素
	SeqList_Destroy(list);//销毁链表
	system("pause");
}
~~~

结果：

![105](F:\学习专用\note\pic\105.png)

#### 案例实现（c++类模板）

~~~c++
#pragma once
template<typename T>
class SeqList
{
public:
	SeqList(int capacity);
	~SeqList();
	int getlen();
	int getcapacity();
	int insert(T &t,int position);
	T& get(int position);
	T& del(int position);
private:
	int len;
	int capacity;
	T *parray;//数组
};
~~~

~~~c++
#include "SeqList.h"


template<typename T>
SeqList<T>::SeqList(int capacity)
{
	parray = new T[capacity];
	this->capacity = capacity;
	this->len = 0;
}

template<typename T>
SeqList<T>::~SeqList()
{
	if (this->parray != NULL)
	{
		delete [] parray;//注意释放一个数组，需加[]
		parray = NULL;
		this->len = 0;
		this->capacity = 0;
	}
}
template<typename T>
int SeqList<T>::getlen()
{
	return this->len;
}
template<typename T>
int SeqList<T>::getcapacity()
{
	return this->capacity;
}
template<typename T>
int SeqList<T>::insert(T &t, int position)
{
	int i = this->len;
	if (position < 0)
	{
		return -1;
	}
	
	for (i;i > position;i--)//元素后移（从最后一个元素开始）
	{
		parray[i] = parray[i-1];
	}
	parray[i] = t;//stl元素保存时是通过复制的机制实现的，自己定义的类需要重载=
	this->len++;
	return 0;
}
template<typename T>
T& SeqList<T>::get(int position)
{
	return this->parray[position];
}
template<typename T>
T& SeqList<T>::del(int position)
{
	if (position<0||position>this->len)
	{
		;
	}
	int i = position;
	T tmp = parray[position];
	for (i=i+1;i < this->len;i++)//元素前移
	{
		parray[i-1] = parray[i];
	}
	this->len--; 
	return tmp;
}
~~~

~~~c++
#include<iostream>
#include"SeqList.cpp"//注意引入的是.cpp文件
using namespace std;

class Student
{
public:
	int age;
	char name[32];
};
void main01()
{
	Student s1, s2, s3, s4;
	s1.age = 10;
	s2.age = 20;
	s3.age = 30;
	s4.age = 40;
	SeqList<Student> list(10);
	list.insert(s1, 0);
	list.insert(s2, 0);
	list.insert(s3, 0);
	list.insert(s4, 0);
	for (int i = 0;i < list.getlen();i++)//遍历
	{
		Student tmp = list.get(i);
		cout << tmp.age << " ";
	}
	cout << endl;
	list.del(0);//删除位置0的元素
	for (  int i = 0;i < list.getlen();i++)
	{
		Student tmp = list.get(i);
		cout << tmp.age << " ";
	}
	cout << endl;
	while (list.getlen() > 0)
	{
		list.del(0);
	}
	cout << list.getlen() << endl;
	system("pause");
}
void main()
{
	Student *s1=new Student;
	Student *s2 = new Student;
	Student *s3 = new Student;
	Student *s4 = new Student;
	s1->age = 10;
	s2->age = 20;
	s3->age = 30;
	s4->age = 40;
	SeqList<Student *> list(10);
	list.insert(s1, 0);
	list.insert(s2, 0);
	list.insert(s3, 0);
	list.insert(s4, 0);
	for (int i = 0;i < list.getlen();i++)//遍历
	{
		Student *tmp = list.get(i);
		cout << tmp->age << " ";
	}
	cout << endl;
	list.del(0);//删除位置0的元素
	for (int i = 0;i < list.getlen();i++)
	{
		Student *tmp = list.get(i);
		cout << tmp->age << " ";
	}
	cout << endl;
	while (list.getlen() > 0)
	{
		list.del(0);
	}
	cout << list.getlen() << endl;
	system("pause");
}
~~~

#### 2.1.3 优点与缺点

**优点：**

- 无须为线性表中的逻辑关系增加额外的空间
- 可以快速的获取表中的合法位置的元素

**缺点：**

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量

### 2.2 线性表的链式存储

#### 2.2.1设计与实现

![108](F:\学习专用\note\pic\108.png)

**插入元素**

![106](F:\学习专用\note\pic\106.png)

**删除元素**

![107](F:\学习专用\note\pic\107.png)

**注意：**

链表带有头节点，返回链表中第3个位置的元素时，需使current指针指向头节点位置，然后向后跳3次，此时指向位置2，再返回**current->next**,即为所求

#### 2.2.2案例

~~~c++
//linklist.h
#pragma once
#include<iostream>
using namespace std;
typedef void linkList;

typedef struct linkListNode
{
	struct linkListNode* next;
}linkListNode;

typedef struct tag_linkList
{
	int len;
	linkListNode header;//头节点
}TlinkList;
//创建线性表
linkList *LinkList_Create();
//销毁线性表
void LinkList_Destroy(linkList *list);
//清空链表 
void linkList_Clear(linkList *list);
//链表长度
int linkList_Length(linkList *list);
//将元素插入线性表
int linkList_Insert(linkList *list, linkListNode *node, int position);
//获取线性表中某个位置的元素
linkListNode *linkList_Get(linkList *list, int position);
//删除元素
linkListNode* linkList_Delete(linkList *list, int position);
~~~

~~~c++
//linklist.c
#include<iostream>
using namespace std;
#include"linklist.h"

//创建线性表
linkList *LinkList_Create()//创建一个头节点
{
	TlinkList *list = NULL;
	list = (TlinkList*)malloc(sizeof(TlinkList));
	memset(list,0,sizeof(TlinkList));
	list->len = 0;
	list->header.next = NULL;
	return list;
}
//销毁线性表
void LinkList_Destroy(linkList *list)
{
	if (list != NULL)
	{
		free(list);
		list = NULL;
	}
	return ;
}
//清空链表 
void linkList_Clear(linkList *list)
{
	TlinkList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TlinkList *)list;
	tlist->len = 0;
	tlist->header.next = NULL;
	return ;
}
//链表长度
int linkList_Length(linkList *list)
{
	TlinkList *tlist = NULL;
	if (list == NULL)
	{
		return 0;
	}
	tlist = (TlinkList *)list;
	
	return tlist->len;
}
//将元素插入线性表 !!!!!!!!!!!!!!!!!!!!!!
int linkList_Insert(linkList *list, linkListNode *node, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *current = NULL;//current为插入位置的前一个元素
	int ret = 0;
	if (list == NULL||node==NULL||position<0)
	{
		ret = -1;
		cout << "func linkList_Insert() err :" << ret << endl;
		return ret;
	}
	tlist = (TlinkList *)list;
	current= &(tlist->header);//获得链表的首元素地址
	for (int i = 0;i < position;i++)//将current指向插入位置的前一个元素的位置
	{
		current = current->next;
	}
	node->next=current->next;//此时current->next即为插入前的下一个元素的位置，让node连接后续链表
	current->next=node;//让前面的链表 连接新的node节点
	tlist->len++;
	return 0;
}
//获取线性表中某个位置的元素 !!!!!!!!!!!!!!
linkListNode *linkList_Get(linkList *list, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *tmp = NULL;
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Get() err :" << ret << endl;
		return (linkListNode *)ret;
	}
	tlist = (TlinkList *)list;
	tmp =&( tlist->header);
	for (i;i<position;i++ )//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	
	return tmp->next;
}
//删除元素 !!!!!!!!!!!!!!!!!
linkListNode* linkList_Delete(linkList *list, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *tmp = NULL;//删除位置的前一个元素
	linkListNode *tmp2 = NULL;//删除位置的元素
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Delete() err :" << ret << endl;
		return (linkListNode *)ret;
	}
	tlist = (TlinkList *)list;
	tmp = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	tmp2=tmp->next;//获得删除元素的一个元素的位置
	tmp->next = tmp2->next;//删除位置的前一个元素的next指向删除元素的下一个元素,即完成删除操作
	tlist->len--; 
	return tmp2;
}
~~~

~~~c++
//test.c
#define _CRT_SECURE_NO_WARNINGS 
#include<iostream>
using namespace std;
#include"linklist.h"

struct student
{
	student(int i)
	{
		age = i;
	}
	linkListNode node;
	int age;
};
void main()
{

	linkList *list = NULL;
	list=LinkList_Create();
	if (list == NULL)
	{
		return;
	}
	student s1(10), s2(20), s3(30);
	linkList_Insert(list, (linkListNode *)&s1,0);
	linkList_Insert(list, (linkListNode *)&s2, 0);
	linkList_Insert(list, (linkListNode *)&s3, 0);
	cout << linkList_Length(list) << endl;
	for (int i = 0;i < linkList_Length(list);i++)
	{
		student *tmp = (student*)linkList_Get(list,i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: "<<tmp->age << endl;
	}
	linkList_Delete(list,1);
	cout << "-----------------" << endl;
	for (int i = 0;i < linkList_Length(list);i++)
	{
		student *tmp = (student*)linkList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	linkList_Clear(list);
	LinkList_Destroy(list);
	system("pause");
}
~~~

结果：

![109](F:\学习专用\note\pic\109.png)

#### 2.2.3优缺点

**优点：**

- 无需一次性定制链表的容量
- 插入和删除操作无须移动数据元素

**缺点：**

- 数据元素必须保存下一个元素的位置信息
- 获取指定数据的元素操作需要顺序访问之前的元素

### 2.3 循环链表

#### 2.3.1 设计与实现

**插入元素分析**

**普通插入元素（和单链表相同）**

**尾插法（和单链表相同）**![111](F:\学习专用\note\pic\111.png)

**头插法（需求出尾节点，构成循环链表，和单链表不同）**!!!!!!![112](F:\学习专用\note\pic\112.png)

**第一次插入元素时，让游标指向0号节点**!!!!!!![113](F:\学习专用\note\pic\113.png)

**删除节点**!!!!!

![114](F:\学习专用\note\pic\114.png)

#### 2.3.2案例

~~~c++
//circle_list.h
#pragma once
#include<iostream>
using namespace std;
typedef void CircleList;

typedef struct CircleListNode
{
	struct CircleListNode* next;
}CircleListNode;

typedef struct tag_CircleList
{
	int len;
	CircleListNode header;//头节点
}TCircleList;
//创建线性表
CircleList *CircleList_Create();
//销毁线性表
void CircleList_Destroy(CircleList *list);
//清空链表 
void CircleList_Clear(CircleList *list);
//链表长度
int CircleList_Length(CircleList *list);
//将元素插入线性表
int CircleList_Insert(CircleList *list, CircleListNode *node, int position);
//获取线性表中某个位置的元素
CircleListNode *CircleList_Get(CircleList *list, int position);
//删除元素
CircleListNode* CircleList_Delete(CircleList *list, int position);
~~~

~~~c++
//circle_list.c
#include<iostream>
using namespace std;
#include"circle_list.h"

//创建线性表
CircleList *CircleList_Create()//创建一个头节点
{
	TCircleList *list = NULL;
	list = (TCircleList*)malloc(sizeof(TCircleList));
	memset(list, 0, sizeof(TCircleList));
	list->len = 0;
	list->header.next = NULL;
	return list;
}
//销毁线性表
void CircleList_Destroy(CircleList *list)
{
	if (list != NULL)
	{
		free(list);
		list = NULL;
	}
	return;
}
//清空链表 
void CircleList_Clear(CircleList *list)
{
	TCircleList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TCircleList *)list;
	tlist->len = 0;
	tlist->header.next = NULL;
	return;
}
//链表长度
int CircleList_Length(CircleList *list)
{
	TCircleList *tlist = NULL;
	if (list == NULL)
	{
		return 0;
	}
	tlist = (TCircleList *)list;

	return tlist->len;
}
//将元素插入线性表 !!!!!!!!!!!!!!!!!!!!!!
int CircleList_Insert(CircleList *list, CircleListNode *node, int position)
{
	TCircleList *tlist = NULL;
	CircleListNode *current = NULL;//current为插入位置的前一个元素
	int ret = 0;
	if (list == NULL || node == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Insert() err :" << ret << endl;
		return ret;
	}
	tlist = (TCircleList *)list;
	current = &(tlist->header);//获得链表的首元素地址
	for (int i = 0;i < position;i++)//将current指向插入位置的前一个元素的位置
	{
		current = current->next;
	}
	node->next = current->next;//此时current->next即为插入前的下一个元素的位置，让node连接后续链表
	current->next = node;//让前面的链表 连接新的node节点
	tlist->len++;
	if (position==0)
	{
		CircleListNode *last = CircleList_Get(tlist, CircleList_Length(tlist) - 1);
		last->next = current->next;
	}
	return 0;
}
//获取线性表中某个位置的元素 !!!!!!!!!!!!!!
CircleListNode *CircleList_Get(CircleList *list, int position)
{
	TCircleList *tlist = NULL;
	CircleListNode *tmp = NULL;
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Get() err :" << ret << endl;
		return (CircleListNode *)ret;
	}
	tlist = (TCircleList *)list;
	tmp = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	return tmp->next;
}
//删除元素 !!!!!!!!!!!!!!!!!
CircleListNode* CircleList_Delete(CircleList *list, int position)
{
	TCircleList *tlist = NULL;
	CircleListNode *tmp = NULL;//删除位置的前一个元素
	CircleListNode *tmp2 = NULL;//删除位置的元素
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Delete() err :" << ret << endl;
		return (CircleListNode *)ret;
	}
	tlist = (TCircleList *)list;
	tmp = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	tmp2 = tmp->next;//获得删除元素的一个元素的位置
	tmp->next = tmp2->next;//删除位置的前一个元素的next指向删除元素的下一个元素,即完成删除操作
	tlist->len--;
	if (position == 0)//从头部删除
	{
		CircleListNode *last = CircleList_Get(tlist, CircleList_Length(tlist) - 1);//获取最后一个元素
		last->next = tmp2->next;//构成循环链表
	}
	return tmp2;
}
~~~

~~~c++
//test.c
#define _CRT_SECURE_NO_WARNINGS 
#include<iostream>
using namespace std;
#include"circle_list.h"

struct student
{
	student(int i)
	{
		age = i;
	}
	CircleListNode node;
	int age;
};
void main()
{

	CircleList *list = NULL;
	list = CircleList_Create();
	if (list == NULL)
	{
		return;
	}
	student s1(10), s2(20), s3(30);
	CircleList_Insert(list, (CircleListNode *)&s1, 0);
	CircleList_Insert(list, (CircleListNode *)&s2, 0);
	CircleList_Insert(list, (CircleListNode *)&s3, 0);
	cout << CircleList_Length(list) << endl;
	for (int i = 0;i < 2*CircleList_Length(list);i++)
	{
		student *tmp = (student*)CircleList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	CircleList_Delete(list, 1);
	cout << "-----------------" << endl;
	cout << CircleList_Length(list) << endl;
	for (int i = 0;i < 2*CircleList_Length(list);i++)
	{
		student *tmp = (student*)CircleList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	CircleList_Delete(list, 0);
	cout << "-----------------" << endl;
	cout << CircleList_Length(list) << endl;
	for (int i = 0;i < 2 * CircleList_Length(list);i++)
	{
		student *tmp = (student*)CircleList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	CircleList_Clear(list);
	CircleList_Destroy(list);
	system("pause");
}
~~~

结果：

![115](F:\学习专用\note\pic\115.png)

###  2.4 双向链表

![116](F:\学习专用\note\pic\116.png)

#### 2.4.1 设计与实现

插入元素

![117](F:\学习专用\note\pic\117.png)

删除元素

![118](F:\学习专用\note\pic\118.jpg)

#### 2.4.2 案例

~~~c++
//dlinklist.h
#pragma once
#include<iostream>
using namespace std;
typedef void DlinkList;

typedef struct DlinkListNode
{
	struct DlinkListNode* next;
	struct DlinkListNode* pre;
}DlinkListNode;

typedef struct tag_DlinkList
{
	int len;
	DlinkListNode header;//头节点
	DlinkListNode *slider;//游标
}TDlinkList;
//创建线性表
DlinkList *DlinkList_Create();
//销毁线性表
void DlinkList_Destroy(DlinkList *list);
//清空链表 
void DlinkList_Clear(DlinkList *list);
//链表长度
int DlinkList_Length(DlinkList *list);
//将元素插入线性表
int DlinkList_Insert(DlinkList *list, DlinkListNode *node, int position);
//获取线性表中某个位置的元素
DlinkListNode *DlinkList_Get(DlinkList *list, int position);
//删除元素（根据位置）
DlinkListNode* DlinkList_Delete(DlinkList *list, int position);
//根据值删除元素
DlinkListNode* DlinkList_DeleteNode(DlinkList *list, DlinkListNode *node);
//游标操作-获得当前游标的元素
DlinkListNode* DlinkList_Current(DlinkList *list);
//游标操作-重置游标
DlinkListNode* DlinkList_Reset(DlinkList *list);
//游标操作-游标后移
DlinkListNode* DlinkList_Next(DlinkList *list);
//游标操作-游标前移
DlinkListNode* DlinkList_Pre(DlinkList *list);
~~~

~~~c++
//dlinklist.c
#include<iostream>
using namespace std;
#include"dlinklist.h"

//创建线性表
DlinkList *DlinkList_Create()//创建一个头节点
{
	TDlinkList *list = NULL;
	list = (TDlinkList*)malloc(sizeof(TDlinkList));
	memset(list, 0, sizeof(TDlinkList));
	list->len = 0;
	list->header.next = NULL;
	list->header.pre = NULL;
	list->slider= NULL;
	return list;
}
//销毁线性表
void DlinkList_Destroy(DlinkList *list)
{
	if (list != NULL)
	{
		free(list);
		list = NULL;
	}
	return;
}
//清空链表 
void DlinkList_Clear(DlinkList *list)
{
	TDlinkList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TDlinkList *)list;
	tlist->len = 0;
	tlist->header.pre = NULL;
	tlist->header.next = NULL;
	tlist->slider = NULL;
	return;
}
//链表长度
int DlinkList_Length(DlinkList *list)
{
	TDlinkList *tlist = NULL;
	if (list == NULL)
	{
		return 0;
	}
	tlist = (TDlinkList *)list;

	return tlist->len;
}
//将元素插入线性表 !!!!!!!!!!!!!!!!!!!!!!
int DlinkList_Insert(DlinkList *list, DlinkListNode *node, int position)
{
	TDlinkList *tlist = NULL;
	DlinkListNode *current = NULL;//current为插入位置的前一个元素
	DlinkListNode *tmp = NULL;//tmp为插入位置的后一个元素
	int ret = 0;
	if (list == NULL || node == NULL || position<0)
	{ 
		ret = -1;
		cout << "func DlinkList_Insert() err :" << ret << endl;
		return ret;
	}
	tlist = (TDlinkList *)list;
	current = &(tlist->header);//获得链表的首元素地址
	for (int i = 0;i < position;i++)//将current指向插入位置的前一个元素的位置
	{
		current = current->next;
	}
	tmp = current->next;
	//步骤1-2
	node->next = tmp;
	current->next = node;
	//步骤3-4
	if (tmp == NULL)//若为尾插或第一次插入时
	{
		;
	}
	else
	{
		tmp->pre = node;
	}
	node->pre = current;
	if (tlist->len == 0)
	{
		tlist->slider = node;//当链表第一次插入时，游标位置,指向第一次插入的位置
	}
	if (current== &(tlist->header))//若为头插法
	{
		node->pre = NULL;
	}
	tlist->len++;

	return 0;
}
//获取线性表中某个位置的元素 !!!!!!!!!!!!!!
DlinkListNode *DlinkList_Get(DlinkList *list, int position)
{
	TDlinkList *tlist = NULL;
	DlinkListNode *tmp = NULL;
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Get() err :" << ret << endl;
		return (DlinkListNode *)ret;
	}
	tlist = (TDlinkList *)list;
	tmp = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	return tmp->next;
}
//删除元素 !!!!!!!!!!!!!!!!!
DlinkListNode* DlinkList_Delete(DlinkList *list, int position)
{
	TDlinkList *tlist = NULL;
	DlinkListNode *current = NULL;//删除位置的前一个元素
	DlinkListNode *tmp = NULL;//删除位置的元素
	DlinkListNode *next = NULL;//删除元素的下一个位置
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Delete() err :" << ret << endl;
		return (DlinkListNode *)ret;
	}
	tlist = (TDlinkList *)list;
	current = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		current = current->next;
	}
	tmp = current->next;//获得删除元素的位置
	next = tmp->next;
	//步骤1
	current->next = next;
	if (next == NULL)//删除尾部
	{
		;
	}
	else
	{
		next->pre = current;//步骤2
		if (current == &(tlist->header))//若删除位置为0
		{
			next->pre = NULL;
		}
	}
	if (tlist->slider==tmp)//若游标位置处于删除位置
	{
		tlist->slider = next;
	}
	tlist->len--;
	return tmp;
}
DlinkListNode* DlinkList_DeleteNode(DlinkList *list, DlinkListNode *node)
{
	TDlinkList *tlist = (TDlinkList *)list;
	DlinkListNode *ret = NULL;
	int i = 0;
	DlinkListNode *current = &(tlist->header);
	if (tlist != NULL)
	{
		for (i;i<tlist->len;i++)
		{
			if (current->next == node)
			{
				ret = current->next;
				break;
			}
			current = current->next;
		}
		if (ret != NULL)
		{
			DlinkList_Delete(tlist,i);
		}
	}
	return ret;
}
DlinkListNode* DlinkList_Reset(DlinkList *list)
{
	TDlinkList *tlist = (TDlinkList *)list;
	DlinkListNode* ret = NULL;
	if (tlist != NULL)
	{
		tlist->slider = tlist->header.next;
		ret = tlist->slider;
	}
	return ret;
}
DlinkListNode* DlinkList_Current(DlinkList *list)
{
	TDlinkList *tlist = (TDlinkList *)list;
	DlinkListNode* ret = NULL;
	if (tlist != NULL)
	{
		ret = tlist->slider;
	}
	return ret;
}
DlinkListNode* DlinkList_Next(DlinkList *list)
{
	TDlinkList *tlist = (TDlinkList *)list;
	DlinkListNode* ret = NULL;
	if ((tlist != NULL)&&(tlist->slider!=NULL))
	{
		ret = tlist->slider->next;
	}
	return ret;
}
DlinkListNode* DlinkList_Pre(DlinkList *list)
{
	TDlinkList *tlist = (TDlinkList *)list;
	DlinkListNode* ret = NULL;
	if ((tlist != NULL) && (tlist->slider != NULL)) 
	{
		ret = tlist->slider->pre;
	}
	return ret;
}
~~~

~~~c++
//test.c
#define _CRT_SECURE_NO_WARNINGS 
#include<iostream>
using namespace std;
#include"dlinklist.h"

struct student
{
	student(int i)
	{
		age = i;
	}
	DlinkListNode node;
	int age;
};
void main()
{

	DlinkList *list = NULL;
	list = DlinkList_Create();
	if (list == NULL)
	{
		return;
	}
	student s1(10), s2(20), s3(30),s4(40),s5(50);
	DlinkList_Insert(list, (DlinkListNode *)&s1, 0);
	DlinkList_Insert(list, (DlinkListNode *)&s2, 0);
	DlinkList_Insert(list, (DlinkListNode *)&s3, 0);
	DlinkList_Insert(list, (DlinkListNode *)&s4, 0);
	DlinkList_Insert(list, (DlinkListNode *)&s5, 0);
	cout << DlinkList_Length(list) << endl;
	for (int i = 0;i < DlinkList_Length(list);i++)
	{
		student *tmp = (student*)DlinkList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	cout << "-----------------" << endl;
	student *t2 = (student *)DlinkList_Current(list);
	cout << "student age: " << t2->age << endl;
	DlinkList_Delete(list, 1);
	cout << "-----------------" << endl;
	cout << DlinkList_Length(list) << endl;
	for (int i = 0;i < DlinkList_Length(list);i++)
	{
		student *tmp = (student*)DlinkList_Get(list, i);
		if (tmp == NULL)
		{
			return;
		}
		cout << "student age: " << tmp->age << endl;
	}
	cout << "-----------------" << endl;
	student *t = (student *)DlinkList_DeleteNode(list, (DlinkListNode *)&s5);
	cout << "student age: " << t->age << endl;
	cout << "-----------------" << endl;
	student *t3 = (student *)DlinkList_Pre(list);
	cout << "student age: " << t3->age << endl;
	DlinkList_Clear(list);
	DlinkList_Destroy(list);
	system("pause");
}
~~~

结果：

![119](F:\学习专用\note\pic\119.png)

####   2.4.3 优缺点

**优点：**

双向链表在单链表的基础上增加了指向前驱的指针

功能上双向链表可以完全取代单链表的使用

含Next,Pre和Current操作可以高效的遍历链表中的所有元素

**缺点：**

代码复杂

## 3. stack栈

**stack的基本操作**

创建栈

销毁栈

清空栈

进栈

出栈

获取栈顶元素

获取栈的大小

### 3.1 stack线性存储

栈的顺序存储，相当于从线性表的尾部插入和删除元素

~~~c++
//seqlist.h
#pragma once
#include<iostream>
using namespace std;
typedef void SeqList;
typedef void SeqListNode;

typedef struct tag_SeqList
{
	int len;
	int capacity;
	unsigned int *node;//int *node[]
}TSeqList;
//创建线性表
SeqList *SeqList_Create(int capacity);
//销毁线性表
void SeqList_Destroy(SeqList *list);
//清空链表 
void SeqList_Clear(SeqList *list);
//链表长度
int SeqList_Length(SeqList *list);
//链表容量
int SeqList_Capacity(SeqList *list);
//将元素插入线性表
int SeqList_Insert(SeqList *list, SeqListNode *node, int position);
//获取线性表中某个位置的元素
SeqListNode *SeqList_Get(SeqList *list, int position);
//删除元素
SeqListNode* SeqList_Delete(SeqList *list, int position);
~~~

~~~c++
//seqlist.cpp
#pragma once
#include<iostream>
using namespace std;
#include"seqlist.h"
//创建链表
SeqList *SeqList_Create(int capacity)
{
	int ret = 0;
	TSeqList *tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret = -1;
		cout << "func SeqList_Create() err : " << ret << endl;
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));
	//根据capacity分配节点空间
	tmp->node = (unsigned int *)malloc(sizeof(unsigned int *)*capacity);
	if (tmp->node == NULL)
	{
		ret = -2;
		cout << "func SeqList_Create() err : " << ret << endl;
		return NULL;
	}
	tmp->capacity = capacity;
	tmp->len = 0;
	return tmp;
}
//销毁链表
void SeqList_Destroy(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TSeqList *)list;
	if (tlist->node != NULL)
	{
		free(tlist->node);
	}
	free(tlist);
}
//清空链表 
void SeqList_Clear(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TSeqList *)list;
	tlist->len = 0;
}
//链表长度
int SeqList_Length(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->len;
}
//链表容量
int SeqList_Capacity(SeqList *list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->capacity;
}
//插入元素 ！！！！！！！！！！！！
int SeqList_Insert(SeqList *list, SeqListNode *node, int position)
{
	int ret = 0;
	int i = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || node == NULL || position<0)
	{
		ret = -1;
		cout << "func SeqList_Insert() err: " << ret << endl;
		return ret;
	}
	tlist = (TSeqList *)list;
	//判断容量是否已满
	if (tlist->capacity <= tlist->len)
	{
		ret = -2;
		cout << "func SeqList_Insert() err (tlist->capacity <= tlist->len) err : " << ret << endl;
		return ret;
	}
	//容器修正，长度为6 容量20 用户插入位置为10
	if (position >= tlist->len)
	{
		position = tlist->len;
	}
	//元素后移
	for (i = tlist->len; i > position; i--)
	{
		tlist->node[i] = tlist->node[i - 1];//tlist->node[i]为最后一个元素的下一个位置
	}
	//插入元素
	tlist->node[i] = (unsigned int)node;
	tlist->len++;
}
SeqListNode *SeqList_Get(SeqList *list, int position)
{
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || position < 0)
	{
		cout << "func SeqList_Get() err : " << endl;
		return NULL;
	}
	tlist = (TSeqList *)list;
	ret = (void *)tlist->node[position];
	return ret;
}
//删除元素 ！！！！！！！！！！！
SeqListNode* SeqList_Delete(SeqList *list, int position)
{
	int i = 0;
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;
	if (list == NULL || position < 0)
	{
		cout << "func SeqList_Delete() err : " << endl;
		return NULL;
	}
	tlist = (TSeqList *)list;
	ret = (void *)tlist->node[position];
	//元素前移
	for (i = position;i < tlist->len;i++)//从position位置后面的元素前移
	{
		tlist->node[i] = tlist->node[i + 1];
	}
	tlist->len--;
	return ret;
}
~~~

~~~c++
//seqstack.h
#pragma once
#include<iostream>
using namespace std;
typedef void SeqStack;
//创建栈
SeqStack *SeqStack_Create(int capacity);
//销毁栈
void SeqStack_Destroy(SeqStack *stack);
//清空栈
void SeqStack_Clear(SeqStack *stack);
//进栈
int SeqStack_Push(SeqStack *stack,void *item);
//出栈
void *SeqStack_Pop(SeqStack *stack);
//获取栈顶元素
void *SeqStack_Top(SeqStack *stack);
//获取栈的大小
int SeqStack_Size(SeqStack *stack);
//获取栈的容量
int SeqStack_Capacity(SeqStack *stack);
~~~

~~~c++
//seqstack.c
#include<iostream>
#include"seqstack.h"
#include "seqlist.h"
using namespace std;

//创建栈 相当于 创建线性表
SeqStack *SeqStack_Create(int capacity)
{
	return SeqList_Create(capacity);
}
//销毁栈 相当于 销毁线性表
void SeqStack_Destroy(SeqStack *stack)
{
	SeqList_Destroy(stack);
}
//清空栈 相当于 清空线性表
void SeqStack_Clear(SeqStack *stack)
{
	SeqList_Clear(stack);
}
//压栈 相当于 从线性表的尾端插入元素
int SeqStack_Push(SeqStack *stack, void *item)
{
	return SeqList_Insert(stack,item, SeqStack_Size(stack));
}
//出栈 相当于 从线性表的尾端取元素
void *SeqStack_Pop(SeqStack *stack)
{
	return SeqList_Delete(stack, SeqStack_Size(stack)-1);//注意元素从位置0开始
}
//获取栈顶元素 相当于 从线性表的尾端获取元素
void *SeqStack_Top(SeqStack *stack)
{
	return SeqList_Get(stack, SeqStack_Size(stack) - 1);
}
//获取栈的大小 相当于 获取线性表的大小
int SeqStack_Size(SeqStack *stack)
{
	return SeqList_Length(stack);
}
//获取栈的容量 相当于 获取线性表的容量
int SeqStack_Capacity(SeqStack *stack)
{
	return SeqList_Capacity(stack);
}
~~~

~~~c++
//test.c
#include<iostream>
#include"seqstack.h"
using namespace std;

void main()
{
	SeqStack *stack = NULL;
	int a[10];
	stack = SeqStack_Create(10);
	if (stack == NULL)
	{
		return;
	}
	for (int i = 0;i < 5;i++)
	{
		a[i] = i + 10;
		SeqStack_Push(stack,&a[i]);
	}
	cout<<"stack size: "<<SeqStack_Size(stack)<<endl;
	cout << "stack Capacity: " << SeqStack_Capacity(stack) << endl;
	while (SeqStack_Size(stack)>0)
	{
		int tmp= *(int *)SeqStack_Top(stack);
		cout << tmp << endl;
		SeqStack_Pop(stack);
	}
	cout << "stack size: " << SeqStack_Size(stack) << endl;
	SeqStack_Destroy(stack);
	system("pause");
}
~~~

结果:

![120](F:\学习专用\note\pic\120.png)

### 3.2 stack链式存储

~~~c++
//linklist.h
#pragma once
#include<iostream>
using namespace std;
typedef void linkList;

typedef struct linkListNode
{
	struct linkListNode* next;
}linkListNode;

//创建线性表
linkList *LinkList_Create();
//销毁线性表
void LinkList_Destroy(linkList *list);
//清空链表 
void linkList_Clear(linkList *list);
//链表长度
int linkList_Length(linkList *list);
//将元素插入线性表
int linkList_Insert(linkList *list, linkListNode *node, int position);
//获取线性表中某个位置的元素
linkListNode *linkList_Get(linkList *list, int position);
//删除元素
linkListNode* linkList_Delete(linkList *list, int position);
~~~

~~~c++
//linklist.c
#include<iostream>
using namespace std;
#include"linklist.h"
typedef struct tag_linkList
{
	int len;
	linkListNode header;
}TlinkList;//链表的业务节点
//创建线性表
linkList *LinkList_Create()//创建一个头节点
{
	TlinkList *list = NULL;
	list = (TlinkList*)malloc(sizeof(TlinkList));
	memset(list,0,sizeof(TlinkList));
	list->len = 0;
	list->header.next = NULL;
	return list;
}
//销毁线性表
void LinkList_Destroy(linkList *list)
{
	if (list != NULL)
	{
		free(list);
		list = NULL;
	}
	return ;
}
//清空链表 
void linkList_Clear(linkList *list)
{
	TlinkList *tlist = NULL;
	if (list == NULL)
	{
		return;
	}
	tlist = (TlinkList *)list;
	tlist->len = 0;
	tlist->header.next = NULL;
	return ;
}
//链表长度
int linkList_Length(linkList *list)
{
	TlinkList *tlist = NULL;
	if (list == NULL)
	{
		return 0;
	}
	tlist = (TlinkList *)list;
	
	return tlist->len;
}
//将元素插入线性表 !!!!!!!!!!!!!!!!!!!!!!
int linkList_Insert(linkList *list, linkListNode *node, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *current = NULL;//current为插入位置的前一个元素
	int ret = 0;
	if (list == NULL||node==NULL||position<0)
	{
		ret = -1;
		cout << "func linkList_Insert() err :" << ret << endl;
		return ret;
	}
	tlist = (TlinkList *)list;
	current= &(tlist->header);//获得链表的首元素地址
	for (int i = 0;i < position;i++)//将current指向插入位置的前一个元素的位置
	{
		current = current->next;
	}
	node->next=current->next;//此时current->next即为插入前的下一个元素的位置，让node连接后续链表
	current->next=node;//让前面的链表 连接新的node节点
	tlist->len++;
	return 0;
}
//获取线性表中某个位置的元素 !!!!!!!!!!!!!!
linkListNode *linkList_Get(linkList *list, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *tmp = NULL;
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Get() err :" << ret << endl;
		return (linkListNode *)ret;
	}
	tlist = (TlinkList *)list;
	tmp =&( tlist->header);
	for (i;i<position;i++ )//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	
	return tmp->next;
}
//删除元素 !!!!!!!!!!!!!!!!!
linkListNode* linkList_Delete(linkList *list, int position)
{
	TlinkList *tlist = NULL;
	linkListNode *tmp = NULL;//删除位置的前一个元素
	linkListNode *tmp2 = NULL;//删除位置的元素
	int i = 0;
	int ret = 0;
	if (list == NULL || position<0)
	{
		ret = -1;
		cout << "func linkList_Delete() err :" << ret << endl;
		return (linkListNode *)ret;
	}
	tlist = (TlinkList *)list;
	tmp = &(tlist->header);
	for (i;i<position;i++)//使tmp指向position的前一个位置
	{
		tmp = tmp->next;
	}
	tmp2=tmp->next;//获得删除元素的一个元素的位置
	tmp->next = tmp2->next;//删除位置的前一个元素的next指向删除元素的下一个元素,即完成删除操作
	tlist->len--; 
	return tmp2;
}
~~~

~~~c++
//linkstack.h
#pragma once
#include<iostream>
using namespace std;
typedef void LinkStack;
//创建栈
LinkStack *LinkStack_Create();
//销毁栈
void LinkStack_Destroy(LinkStack *stack);
//清空栈
void LinkStack_Clear(LinkStack *stack);
//进栈
int LinkStack_Push(LinkStack *stack, void *item);
//出栈
void *LinkStack_Pop(LinkStack *stack);
//获取栈顶元素
void *LinkStack_Top(LinkStack *stack);
//获取栈的大小
int LinkStack_Size(LinkStack *stack);

~~~

~~~c++
//linkstack.c
#include<iostream>
#include"linkstack.h"
#include"linklist.h"
using namespace std;

typedef struct tag_LinkStackNode//链表的业务节点
{
	linkListNode node;
	void *item;//栈的业务节点
}TLinkStackNode;
//创建栈 相当于 创建链表
LinkStack *LinkStack_Create()
{
	return LinkList_Create();
}
//销毁栈
//先清空栈，再销毁
void LinkStack_Destroy(LinkStack *stack)
{
	LinkStack_Clear(stack);
	LinkList_Destroy(stack);
	return ;
}
//清空栈 相当于清空链表
//此时，由于入栈时给每个元素都分配了内存，需把栈中元素弹出，并释放节点内存
void LinkStack_Clear(LinkStack *stack)
{
	if (stack == NULL)
	{
		return;
	}
	while (LinkStack_Size(stack) > 0)
	{
		LinkStack_Pop(stack);//出栈，并释放节点内存
	}
	return ;
}
//进栈
//向栈中添加元素 相当于 向线性表的头部插入元素
//void *item 栈的业务节点--》转化为 链表的业务节点
int LinkStack_Push(LinkStack *stack, void *item)
{
	TLinkStackNode *tnode= NULL;
	int ret = 0;
	tnode = (TLinkStackNode*)malloc(sizeof(TLinkStackNode));
	if (tnode == NULL)
	{
		return -1;
	}
	memset(tnode, 0, sizeof(TLinkStackNode));
	tnode->item = item;
	ret = linkList_Insert(stack, (linkListNode *)tnode, 0);
	if (ret != 0)
	{
		cout << "func linkList_Insert() err " << endl;
		if (tnode != NULL)
		{
			free(tnode);
		}
		return ret;
	}
	return ret;
}
//出栈
//出栈，相当于 从链表的头部删除元素
//把线性表的业务节点 转换成栈的业务节点 
void *LinkStack_Pop(LinkStack *stack)
{
	void *item = NULL;//栈的业务节点
	TLinkStackNode *tnode = NULL;
	tnode = (TLinkStackNode *)linkList_Delete(stack,0);
	if (tnode == NULL)
	{
		return NULL;
	}
	item = tnode->item;
	//linkList_Insert时分配了内存 出栈时 需释放内存
	free(tnode);
	return item;
}
//获取栈顶元素 相当于获取链表的头部元素
void *LinkStack_Top(LinkStack *stack)
{
	void *item = NULL;//栈的业务节点
	TLinkStackNode *tnode = NULL;
	tnode = (TLinkStackNode *)linkList_Get(stack, 0);
	if (tnode == NULL)
	{
		return NULL;
	}
	item = tnode->item;
	return item;
}
//获取栈的大小
int LinkStack_Size(LinkStack *stack)
{
	return linkList_Length(stack);
}
~~~

~~~c++
//test.c
#include<iostream>
#include"linkstack.h"
using namespace std;

void main()
{
	LinkStack *stack = NULL;
	int a[10];
	stack = LinkStack_Create();
	if (stack == NULL)
	{
		return;
	}
	for (int i = 0;i < 5;i++)
	{
		a[i] = i + 10;
		LinkStack_Push(stack, &a[i]);
	}
	cout << "stack size: " << LinkStack_Size(stack) << endl;
	while (LinkStack_Size(stack)>0)
	{
		int tmp = *(int *)LinkStack_Top(stack);
		cout << tmp << endl;
		LinkStack_Pop(stack);
	}
	cout << "stack size: " << LinkStack_Size(stack) << endl;
	LinkStack_Destroy(stack);
	system("pause");
}
~~~

结果：

![121](F:\学习专用\note\pic\121.png)

### 3.3 栈的应用

#### 应用1

![122](F:\学习专用\note\pic\122.png)

~~~c++
#include<iostream>
#include"linkstack.h"//引用上述中的stack链式存储
using namespace std;
int isleft(char c)
{
	int ret = 0;
	switch (c)
	{
	case'<':
		ret = 1;
		break;
	case'{':
		ret = 1;
		break;
	case'[':
		ret = 1;
		break;
	case'(':
		ret = 1;
		break;
	default:
		break;
	}
	return ret;
}
int isright(char c)
{
	int ret = 0;
	switch (c)
	{
	case'>':
		ret = 1;
		break;
	case'}':
		ret = 1;
		break;
	case']':
		ret = 1;
		break;
	case')':
		ret = 1;
		break;
	default:
		break;
	}
	return ret;
}
void scan(char *code)
{
	LinkStack *stack = NULL;
	int i = 0;
	int ret = 0;
	stack = LinkStack_Create();
	if (stack == NULL)
	{
		return;
	}
	while (code[i] != '\0')
	{
		if (isleft(code[i]))
		{
			LinkStack_Push(stack,(void *)code[i]);
		}
		else if (isright(code[i]))
		{
			LinkStack_Pop(stack);
		}
		i++;
	}
	if (LinkStack_Size(stack) != 0)
	{
		cout << "语法错误！！！" << endl;
	}
	else
	{
		cout << "语法正确" << endl;
	}
}
void main()
{
	char *code = "#Include <iostream>; void main(){int i=0;int a[10];";
	scan(code);
	system("pause");
}
~~~

结果：

![123](F:\学习专用\note\pic\123.png)

#### 应用2

![124](F:\学习专用\note\pic\124.png)

![125](F:\学习专用\note\pic\125.png)

#### 应用3

 ![126](F:\学习专用\note\pic\126.png)

~~~c++
#include<iostream>
#include"linkstack.h"//引用上述中的stack链式存储
using namespace std;
bool isNum(char str)
{
	return (str >= '0') && (str <= '9');
}
bool isOperator(char str)
{
	return (str == '+' || '-' || '*' || '/');
}
int Run(int l, int r, char opt)
{
	int ret = 0;
	int left = l-'0';
	int right = r-'0';
	switch (opt)
	{
	case'+':
		ret = left + right;
		break;
	case'-':
		ret = left - right;
		break;
	case'*':
		ret = left * right;
		break;
	case'/':
		ret = left / right;
		break;
	}
	return ret+'0';
}
int computer(char *str)
{
	int i = 0;
	LinkStack *stack = NULL;
	stack = LinkStack_Create();
	while (str[i] != '\0')
	{
		if (isNum(str[i]))
		{
			LinkStack_Push(stack, (void *)str[i]);
		}
		else if (isOperator(str[i]))
		{
			int right=(int)LinkStack_Pop(stack);
			int left = (int)LinkStack_Pop(stack);
			int result=Run(left,right,str[i]);
			LinkStack_Push(stack, (void *)result);
		}
		i++;
	}
	if ((LinkStack_Size(stack) == 1) && (str[i] == '\0'))
	{
		int ret = (int)LinkStack_Top(stack);
		LinkStack_Destroy(stack);
		return ret-'0';
	}
	else
	{
		cout << "err expression" << endl;
		LinkStack_Destroy(stack);
		return 0;
	}
}

void main()
{
	printf("5-(3+2)*6=%d\n",computer("532+6*-"));
	system("pause");
}
~~~

## 4. Queue队

**基本操作**

创建队列

销毁队列

清空队列

出队列

进队列

获取队头元素

获取队列长度

### 4.1 队列的顺序存储

~~~c++
//seqqueue.h
#pragma once
#include<iostream>
using namespace std;
typedef void SeqQueue;

//创建队列
SeqQueue *SeqQueue_Create(int capacity);
//销毁队列
void SeqQueue_Destroy(SeqQueue *queue);
//清空队列
void SeqQueue_Clear(SeqQueue *queue);
//进队列
int SeqQueue_Append(SeqQueue *queue, void *item);
//出队列
void *SeqQueue_OutQueue(SeqQueue *queue);
//获取队头元素
void *SeqQueue_Header(SeqQueue *queue);
//获取队长度
int SeqQueue_Length(SeqQueue *queue);
//获取队容量
int SeqQueue_Capacity(SeqQueue *queue);
~~~

~~~c++
//seqqueue.c
#include<iostream>
#include"seqqueue.h"
#include"seqlist.h"
using namespace std;

//队列为一种特殊的线性表
//创建队列 相当于 创建一个顺序存储线性表
SeqQueue *SeqQueue_Create(int capacity)
{
	return SeqList_Create(capacity);
}
//销毁队列 相当于 销毁线性表
void SeqQueue_Destroy(SeqQueue *queue)
{
	 SeqList_Destroy(queue);
}
//清空队列 相当于 清空线性表
void SeqQueue_Clear(SeqQueue *queue)
{
	 SeqList_Clear(queue);
}
//进队列 相当于 从线性表的尾部插入元素
int SeqQueue_Append(SeqQueue *queue, void *item)
{
	return SeqList_Insert(queue,item, SeqQueue_Length(queue));
}
//出队列 相当于 从线性表的头部删除元素
void *SeqQueue_OutQueue(SeqQueue *queue)
{
	return SeqList_Delete(queue, 0);;
}
//获取队头元素 相当于 获取线性表的头部元素
void *SeqQueue_Header(SeqQueue *queue)
{
	return SeqList_Get(queue,0);
}
//获取队长度 相当于 获取线性表的长度
int SeqQueue_Length(SeqQueue *queue)
{
	return SeqList_Length(queue);
}
//获取队容量 相当于 获取线性表的容量
int SeqQueue_Capacity(SeqQueue *queue)
{
	return SeqList_Capacity(queue);
}
~~~

~~~c++
//test.c
#include<iostream>
#include"seqqueue.h"
#include"seqlist.h"
using namespace std;

void main()
{
	SeqQueue *queue = NULL;
	int a[10];
	queue = SeqQueue_Create(10);
	if (queue == NULL)
	{
		return;
	}
	for (int i = 0;i < 5;i++)
	{
		a[i] = i + 10;
		SeqQueue_Append(queue, &a[i]);
	}
	cout << SeqQueue_Length(queue) << endl;//打印队列长度
	cout << SeqQueue_Capacity(queue) << endl;//打印队列容量
	int ret = *(int*)SeqQueue_Header(queue);
	cout << "queue header: "<<ret << endl;
	while (SeqQueue_Length(queue) > 0)//遍历整个队列
	{
		int tmp=*(int*)SeqQueue_OutQueue(queue);
		cout << tmp << " ";
	}
	cout << endl;
	SeqQueue_Destroy(queue);
	system("pause");
}
~~~

结果：

![127](F:\学习专用\note\pic\127.png)



### 4.2 队列的链式存储

~~~c++
//LinkQueue.h
#pragma once
#include<iostream>
using namespace std;
typedef void LinkQueue;

//创建队列
LinkQueue *LinkQueue_Create();
//销毁队列
void LinkQueue_Destroy(LinkQueue *queue);
//清空队列
void LinkQueue_Clear(LinkQueue *queue);
//进队列
int LinkQueue_Append(LinkQueue *queue, void *item);
//出队列
void *LinkQueue_OutQueue(LinkQueue *queue);
//获取队头元素
void *LinkQueue_Header(LinkQueue *queue);
//获取队长度
int LinkQueue_Length(LinkQueue *queue);
~~~

~~~c++
//LinkQueue.c
#include<iostream>
#include"LinkQueue.h"
#include"linklist.h"
using namespace std;

typedef struct tag_LinkQueueNode
{
	linkListNode node;//链表的业务节点
	void *item;//队列的业务节点
}TLinkQueueNode;

//队列为一种特殊的线性表
//创建队列 相当于 创建一个链表
LinkQueue *LinkQueue_Create()
{
	return LinkList_Create();
}
//销毁队列
void LinkQueue_Destroy(LinkQueue *queue)
{
	LinkQueue_Clear(queue);
	LinkList_Destroy(queue);
}
//清空队列
void LinkQueue_Clear(LinkQueue *queue)
{
	if (queue == NULL)
	{
		return;
	}
	while (LinkQueue_Length(queue) > 0)
	{
		LinkQueue_OutQueue(queue);//出栈，并释放节点内存
	}
}
//进队列 
//向队列中添加元素 相当于 从链表的尾部插入元素
//需要把队列的业务节点 转为 链表的业务节点
int LinkQueue_Append(LinkQueue *queue, void *item)
{
	int ret = 0;
	TLinkQueueNode *tnode =(TLinkQueueNode *)malloc(sizeof(TLinkQueueNode));
	if (tnode == NULL)
	{
		ret = -1;
		cout << "fun LinkQueue_Append() malloc err: " << ret << endl;
		return ret;
	}
	memset(tnode,0,sizeof(TLinkQueueNode));
	tnode->item = item;
	ret = linkList_Insert(queue,(linkListNode *)tnode, LinkQueue_Length(queue));
	if (ret != 0)
	{
		cout << "func linkList_Insert() err :" << ret << endl;
		return ret;
	}
	return ret;
}
//出队列
//从队列中删除元素 相当于 从链表的头部删除元素
//链表的业务节点转为队列的业务节点
void *LinkQueue_OutQueue(LinkQueue *queue)
{
	void *item = NULL;//栈的业务节点
	TLinkQueueNode *tnode = NULL;
	tnode = (TLinkQueueNode *)linkList_Delete(queue, 0);
	if (tnode == NULL)
	{
		return NULL;
	}
	item = tnode->item;
	//linkList_Insert时分配了内存 出栈时 需释放内存
	free(tnode);
	return item;
}
//获取队头元素 相当于 从链表的0位置取元素
void *LinkQueue_Header(LinkQueue *queue)
{
	void *item = NULL;//栈的业务节点
	TLinkQueueNode *tnode = NULL;
	tnode = (TLinkQueueNode *)linkList_Get(queue, 0);
	if (tnode == NULL)
	{
		return NULL;
	}
	item = tnode->item;
	return item;
}
//获取队长度
int LinkQueue_Length(LinkQueue *queue)
{
	return linkList_Length(queue);
}
~~~

~~~c++
//test.c
#include<iostream>
#include"LinkQueue.h"
#include"linklist.h"
using namespace std;

void main()
{
	LinkQueue *queue = NULL;
	int a[10];
	queue = LinkQueue_Create();
	if (queue == NULL)
	{
		return;
	}
	for (int i = 0;i < 5;i++)
	{
		a[i] = i + 10;
		LinkQueue_Append(queue, &a[i]);
	}
	cout << LinkQueue_Length(queue) << endl;//打印队列长度
	int ret = *(int*)LinkQueue_Header(queue);
	cout << "queue header: "<<ret << endl;
	while (LinkQueue_Length(queue) > 0)//遍历整个队列
	{
		int tmp=*(int*)LinkQueue_OutQueue(queue);
		cout << tmp << " ";
	}
	cout << endl;
	LinkQueue_Destroy(queue);
	system("pause");
}
~~~

## 5.树和二叉树

**树的本质：**

递归定义的，m个互不相交的集合

![129](F:\学习专用\note\pic\128.png)![128](F:\学习专用\note\pic\129.png)

![130](F:\学习专用\note\pic\130.png)

![131](F:\学习专用\note\pic\131.png)

### 5.1 二叉树

#### 5.1.1 二叉树基本定义

![132](F:\学习专用\note\pic\132.png)

#### 5.1.2二叉树性质

![133](F:\学习专用\note\pic\133.png)

![134](F:\学习专用\note\pic\134.png)

![ 137](F:\学习专用\note\pic\137.png)

#### 5.1.3满二叉树和完全二叉树

![135](F:\学习专用\note\pic\135.png)

![136](F:\学习专用\note\pic\136.png)

#### 5.1.4二叉树的顺序存储

![138](F:\学习专用\note\pic\138.png)

#### 5.1.5二叉树的链式存储

![139](F:\学习专用\note\pic\139.png)



#### 5.1.6 树的表示法

**树的二叉链表**

![140](F:\学习专用\note\pic\140.png)

**双亲链表**

![141](F:\学习专用\note\pic\141.png)

~~~c++
#include<iostream>
using namespace std;
//树的二叉链表法
typedef struct BiTNode
{
	int data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTTree;
//树的三叉链表法
typedef struct BiTNode
{
	int data;
	struct BiTNode *lchild, *rchild;
	struct BiTNode *parent;
}BiTNode, *BiTTree;
//树的双亲链表 
typedef struct BPTNode
{
	int data;
	int position;//指向父亲的指针 //父节点数组下标
	int LRTag;//左右孩子的标志
}BPTNode;
typedef struct BPTree
{
	BPTNode node[100];//树中的节点，每个节点有对应的数组下标
	int num_node;//节点数目
	int root;//根节点位置
}BPTree;
void main01()
{
	BiTNode s1, s2, s3, s4;
	s1.data = 10;
	s2.data = 20;
	s3.data = 30;
	s4.data = 40;
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s3;
	s2.lchild = &s4;
	//树的遍历

	system("pause");
}
void main02()
{
	BiTNode *s1, *s2, *s3, *s4;
	s1 = new BiTNode;
	s2 = new BiTNode;
	s3 = new BiTNode;
	s4 = new BiTNode;
	s1->data = 10;
	s2->data = 20;
	s3->data = 30;
	s4->data = 40;
	//建立关系
	s1->lchild = s2;
	s1->rchild = s3;
	s2->lchild = s4;
	//树的遍历

	system("pause");
}
//双亲链表
void main()
{
	BPTree tree;
	tree.root = 1000;
	tree.node[0].position = tree.root;
	tree.node[0].data = 'A';

	tree.node[1].position = 0;
	tree.node[1].data = 'B';
	tree.node[1].LRTag = 1;//A左子结点

	tree.node[2].position = 0;
	tree.node[2].data = 'C';
	tree.node[2].LRTag = 2;//A右子结点

	tree.node[3].position = 0;
	tree.node[3].data = 'D';
	tree.node[3].LRTag = 2;//B右子结点

	tree.node[4].position = 0;
	tree.node[4].data = 'E';
	tree.node[4].LRTag = 2;//C右子结点
	system("pause");
}
~~~

#### 5.1.7 树的遍历

![142](F:\学习专用\note\pic\142.png)

![143](F:\学习专用\note\pic\143.png)

 ~~~c++
#include<iostream>
using namespace std;
//树的二叉链表法
typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTTree;

void preOrder(BiTNode *node)
{
	if (node == NULL)
	{
		return;
	}
	cout << node->data << " ";
	preOrder(node->lchild);//递归,遍历左子树
	preOrder(node->rchild);//递归,遍历右子树
}
void inOrder(BiTNode *node)
{
	if (node == NULL)
	{
		return;
	}
	inOrder(node->lchild);//递归,遍历左子树
	cout << node->data << " ";
	inOrder(node->rchild);//递归,遍历右子树
}
void postOrder(BiTNode *node)
{
	if (node == NULL)
	{
		return;
	}
	postOrder(node->lchild);//递归,遍历左子树
	postOrder(node->rchild);//递归,遍历右子树
	cout << node->data << " ";
}
void main()
{
	BiTNode s1, s2, s3, s4,s5,s6,s7,s8;
	memset(&s1, 0, sizeof(BiTNode));
	memset(&s2, 0, sizeof(BiTNode));
	memset(&s3, 0, sizeof(BiTNode));
	memset(&s4, 0, sizeof(BiTNode));
	memset(&s5, 0, sizeof(BiTNode));
	memset(&s6, 0, sizeof(BiTNode));
	memset(&s7, 0, sizeof(BiTNode));
	memset(&s8, 0, sizeof(BiTNode));
	s1.data = 'A';
	s2.data = 'B';
	s3.data = 'C';
	s4.data = 'D';
	s5.data = 'E';
	s6.data = 'F';
	s7.data = 'G';
	s8.data = 'H';
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s6;
	s2.rchild = &s3;
	s3.lchild = &s4;
	s3.rchild = &s5;
	s6.rchild = &s7;
	s7.lchild = &s8;
	//树的遍历
	cout << "先序遍历： " ;
	preOrder(&s1);
	cout << endl;
	cout << "中序遍历： " ;
	inOrder(&s1);
	cout << endl;
	cout << "后序遍历： " ;
	postOrder(&s1);
	cout << endl;
	system("pause");
}
 ~~~

结果：

![144](F:\学习专用\note\pic\144.png)



分析：

![145](F:\学习专用\note\pic\145.png)

##### 求树的叶子节点

~~~c++
#include<iostream>
using namespace std;
//树的二叉链表法
typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTTree;

void coutLeafnum(BiTNode *node,int *sum)
{
	if (node != NULL)
	{
		if ((node->lchild == NULL) && (node->rchild == NULL))
		{
			(*sum)++;
		}
		if (node->lchild)
		{
			coutLeafnum(node->lchild,sum);
		}
		if (node->rchild)
		{
			coutLeafnum(node->rchild, sum);
		}
	}
}
//求树的叶子节点
void main()
{
	BiTNode s1, s2, s3, s4, s5, s6, s7, s8;
	memset(&s1, 0, sizeof(BiTNode));
	memset(&s2, 0, sizeof(BiTNode));
	memset(&s3, 0, sizeof(BiTNode));
	memset(&s4, 0, sizeof(BiTNode));
	memset(&s5, 0, sizeof(BiTNode));
	memset(&s6, 0, sizeof(BiTNode));
	memset(&s7, 0, sizeof(BiTNode));
	memset(&s8, 0, sizeof(BiTNode));
	s1.data = 'A';
	s2.data = 'B';
	s3.data = 'C';
	s4.data = 'D';
	s5.data = 'E';
	s6.data = 'F';
	s7.data = 'G';
	s8.data = 'H';
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s6;
	s2.rchild = &s3;
	s3.lchild = &s4;
	s3.rchild = &s5;
	s6.rchild = &s7;
	s7.lchild = &s8;
	int sum = 0;
	coutLeafnum(&s1,&sum);
	cout << "叶子节点数为： " << sum << endl;
	system("pause");
}

~~~

结果：

![146](F:\学习专用\note\pic\146.png)

##### 求树的高度

~~~c++
#include<iostream>
using namespace std;
//树的二叉链表法
typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTTree;

int DepthTree(BiTNode *node)
{
	int leftDep=0;int rightDep = 0;
	int Dep=0;
	if (node == NULL)
	{
		return 0;
	} 
	leftDep=DepthTree(node->lchild);//求左子树高度
	rightDep= DepthTree(node->rchild);//求右子树高度
	Dep = 1 + (leftDep > rightDep ? leftDep : rightDep);
	return Dep;
}
//求树的高度
void main()
{
	BiTNode s1, s2, s3, s4, s5, s6, s7, s8;
	memset(&s1, 0, sizeof(BiTNode));
	memset(&s2, 0, sizeof(BiTNode));
	memset(&s3, 0, sizeof(BiTNode));
	memset(&s4, 0, sizeof(BiTNode));
	memset(&s5, 0, sizeof(BiTNode));
	memset(&s6, 0, sizeof(BiTNode));
	memset(&s7, 0, sizeof(BiTNode));
	memset(&s8, 0, sizeof(BiTNode));
	s1.data = 'A';
	s2.data = 'B';
	s3.data = 'C';
	s4.data = 'D';
	s5.data = 'E';
	s6.data = 'F';
	s7.data = 'G';
	s8.data = 'H';
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s6;
	s2.rchild = &s3;
	s3.lchild = &s4;
	s3.rchild = &s5;
	s6.rchild = &s7;
	s7.lchild = &s8;
	int ret=DepthTree(&s1);
	cout << "树的高度为： " << ret<<endl;
	system("pause");
}
~~~

结果：

![147](F:\学习专用\note\pic\147.png)

##### 树的拷贝

~~~c++
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
//树的二叉链表法
typedef struct BiTNode
{
	int data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTTree;

void inOrder(BiTNode *root)
{
	if (root == NULL)
	{
		return;
	}
	cout << root->data << " ";
	inOrder(root->lchild);
	inOrder(root->rchild);
}
BiTNode *CopyTree(BiTNode *root)
{
	if (root == NULL)
	{
		return NULL;
	}
	BiTNode *Node = NULL;
	BiTNode *new_left = NULL;
	BiTNode *new_right = NULL;
	//copy左子树
	if (root->lchild)
	{
		new_left =CopyTree(root->lchild);
	}
	else
	{
		new_left = NULL;
	}
	//copy右子树
	if (root->rchild)
	{
		new_right = CopyTree(root->rchild);
	}
	else
	{
		new_right = NULL;
	}
	Node = new BiTNode;//为每个节点分配内存
	Node->lchild = new_left;
	Node->rchild = new_right;
	Node->data = root->data;
	return Node;
}

void main()
{
	BiTNode s1, s2, s3, s4, s5, s6, s7, s8;
	memset(&s1, 0, sizeof(BiTNode));
	memset(&s2, 0, sizeof(BiTNode));
	memset(&s3, 0, sizeof(BiTNode));
	memset(&s4, 0, sizeof(BiTNode));
	memset(&s5, 0, sizeof(BiTNode));
	memset(&s6, 0, sizeof(BiTNode));
	memset(&s7, 0, sizeof(BiTNode));
	memset(&s8, 0, sizeof(BiTNode));
	s1.data = 1;
	s2.data = 2;
	s3.data = 3;
	s4.data = 4;
	s5.data = 5;
	s6.data = 6;
	s7.data = 7;
	s8.data = 8;
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s6;
	s2.rchild = &s3;
	s3.lchild = &s4;
	s3.rchild = &s5;
	s6.rchild = &s7;
	s7.lchild = &s8;
	//树的遍历	
	inOrder(&s1);

	//树的拷贝
	BiTNode *newtree = CopyTree(&s1);
	inOrder(&s1);
	system("pause");
}
~~~

结果：

![148](F:\学习专用\note\pic\148.png)

##### 树的非递归遍历（中序）

~~~c++
#include<iostream>
#include<stack>
#include<vector>
using namespace std;
typedef struct BiTNode
{
	char data;
	BiTNode* lchild, *rchild;
}BiTNode,*BiTree;

/*
步骤1：
如果节点有左子树，该节点入栈
如果没有，访问该节点
步骤2：
如果节点有右子树，重复步骤1
如果节点没有右子树，根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1
如果栈为空，遍历结束
*/
//一直想左走，找到中序遍历起点
BiTNode *goleft(stack<BiTNode *> &ret, BiTNode *node)
{
	if (node == NULL)
	{
		return NULL;
	}
	while (node->lchild)//判断有没有左子树
	{
		ret.push(node);
		node = node->lchild;
	}
	return node;
}
void inOrder(BiTNode *root)
{
	if (root == NULL)
		return;
	stack<BiTNode *> ret;
	BiTNode *tmp=NULL;
	tmp=goleft(ret,root);
	while (tmp)
	{
		cout << tmp->data << " ";
		if (tmp->rchild)//如果有右子树
		{
			tmp=goleft(ret, tmp->rchild);
		}
		else if(!ret.empty())//如果没有右子树，且栈非空，则回退
		{
			tmp = ret.top();
			ret.pop();	
		}
		else
		{
			tmp = NULL;
		}
	}
	return;
}
void main()
{
	BiTNode s1, s2, s3, s4, s5, s6, s7, s8;
	memset(&s1, 0, sizeof(BiTNode));
	memset(&s2, 0, sizeof(BiTNode));
	memset(&s3, 0, sizeof(BiTNode));
	memset(&s4, 0, sizeof(BiTNode));
	memset(&s5, 0, sizeof(BiTNode));
	memset(&s6, 0, sizeof(BiTNode));
	memset(&s7, 0, sizeof(BiTNode));
	memset(&s8, 0, sizeof(BiTNode));
	s1.data = 'A';
	s2.data ='B';
	s3.data ='C';
	s4.data ='D';
	s5.data ='E';
	s6.data ='F';
	s7.data ='G';
	s8.data ='H';
	//建立关系
	s1.lchild = &s2;
	s1.rchild = &s6;
	s2.rchild = &s3;
	s3.lchild = &s4;
	s3.rchild = &s5;
	s6.rchild = &s7;
	s7.lchild = &s8;

	//非递归遍历（中序）
	inOrder(&s1);
	system("pause");
}
~~~

结果：

![149](F:\学习专用\note\pic\149.png)

### 5.1.8 二叉树的创建

**结论：**

通过中序遍历和先序遍历可以确定一个树

通过中序遍历和后序遍历可以确定一个树

通过先序遍历和后序遍历不能确定一个树

**求二叉树**

先序遍历结果：ADEBCF 

中序遍历结果：DEACFB

**算法：**

1.通过先序遍历找到根节点A，再通过A在中序遍历的位置找出左子树，右子树

2.在A的左子树中，找到左子树的根节点（在先序遍历中找），转步骤1

3.在A的右子树中，找到右子树的根节点（在先序遍历中找），转步骤1

##  6. 排序

 **排序的稳定性**

如果两个数据元素r[i]和r[j],他们的值相等，且在排序前，元素r[i]在r[j]之前。若排序后，元素r[i]仞在r[j]之前，则这个排序是稳定的，否则不稳定

**排序中的关键操作**

比较，交换

**内排序和外排序**

内排序：整个排序过程不需要访问外存便能完成

外排序：待排序的数据元素数量很大，整个序列的排序过程不可能在内存中完成

### 6.1 选择法（n*n）

![150](F:\学习专用\note\pic\150.png)

~~~c++
#include<iostream>
using namespace std;

void SelectSort(int *arr,int len)
{
	int k;//最小元素的下标
	int tmp=0;
	for (int i=0;i<len;i++)
	{	
		k = i;
		for (int j=i+1;j<len;j++)
		{
			if (arr[j] < arr[k])//比较，找到最小元素，取其下标
			{
				k = j;
			}
		}
		//元素替换
		tmp= arr[i];
		arr[i] = arr[k];
		arr[k] = tmp;
	}
	return ;
}

void main()
{
	int arr[] = {2,1,4,43,22,67,98,12,3 };
	int len = sizeof(arr) / sizeof(arr[1]);
	SelectSort(arr,len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
}
~~~

结果：

![153](F:\学习专用\note\pic\153.png)

### 6.2 插入排序(n*n)

![152](F:\学习专用\note\pic\152.png)

~~~c++
#include<iostream>
using namespace std;

void InsertSort(int *arr, int len)
{
	int k;
	int tmp = 0;
	for (int i = 1;i<len;i++)//从位置1开始
	{
		tmp = arr[i];
		for (int j = i-1;j >=0;j--)//依次比较i位置前面的元素，
		{
			if (arr[j] > tmp)//位置调换，较大元素后移，插入tmp
			{
				arr[j+1] = arr[j];
                arr[j] = tmp;
			}
		}
	}
	return;
}

void main()
{
	int arr[] = { 2,1,4,43,22,67,98,12,3 };
	int len = sizeof(arr) / sizeof(arr[1]);
	InsertSort(arr, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
}
~~~

结果：

![153](F:\学习专用\note\pic\153.png)



### 6.3 冒泡排序(n*n)

![156](F:\学习专用\note\pic\156.png)

![157](F:\学习专用\note\pic\157.png)

![162](F:\学习专用\note\pic\162.png)

 ~~~c++
#include<iostream>
using namespace std;
//向后冒泡，求出每趟最大值，放到最后
void BubbleSort(int *arr, int len)
{
	int tmp = 0;
	int i;
	for (i = 0;i<len-1;i++)
	{
		for (int j = 0;j <len-1-i;j++)//从最前两个位置开始比较
		{
			if (arr[j+1] < arr[j])//比较相邻位置大小，前者比后者大，则调换位置
			{
				tmp = arr[j+1];
				arr[j+1] = arr[j];
				arr[j] = tmp;
			}
		}
	}
	cout << "向后冒泡排序轮数： "<< i + 1 << endl;
	return;
}
//向前冒泡，求出每趟最小值，放到最前
void BubbleSort1(int *arr, int len)
{
	int tmp = 0;
	int i;
	for (i = 0;i<len-1;i++)//趟数
	{
		for (int j = len-1;j >i;j--)//从最后两个位置开始比较
		{
			if (arr[j] < arr[j-1])//比较相邻位置大小，前者比后者大，则调换位置
			{
				tmp = arr[j];
				arr[j] = arr[j-1];
				arr[j-1] = tmp;
			}
		}
	}
	cout << "向前冒泡排序轮数： " << i + 1 << endl;
	return;
}
//向后冒泡优化
void BubbleSort2(int *arr, int len)
{
	int tmp = 0;
	int tag = 1;//标志：表明数组是否排好序，0排好序，1没有排好
	int i;
	for (i = 0;(i<len-1)&&tag;i++)//从位置0开始
	{
		tag = 0;//排序后，认为排序完成
		for (int j = 0;j <len-1-i;j++)
		{
			if (arr[j+1] < arr[j])//比较相邻位置大小，前者比后者大，则调换位置
			{
				tmp = arr[j+1];
				arr[j+1] = arr[j];
				arr[j] = tmp;
				tag = 1;//if为真，则未完成排序，需继续排序
			}
		}
	}
	cout << "优化后的向后冒泡排序轮数： " << i +1<< endl;
	return;
}
//向前冒泡优化
void BubbleSort3(int *arr, int len)
{
	int tmp = 0;
	int tag = 1;//标志：表明数组是否排好序，0排好序，1没有排好
	int i;
	for (i = 0;(i<len - 1) && tag;i++)//从位置0开始
	{
		tag = 0;//排序后，认为排序完成
		for (int j = len-1;j >i;j--)
		{
				if (arr[j] < arr[j - 1])//比较相邻位置大小，前者比后者大，则调换位置
				{
					tmp = arr[j];
					arr[j] = arr[j - 1];
					arr[j - 1] = tmp;
					tag = 1;//if为真，则未完成排序，需继续排序
				}
		}
	}
	cout << "优化后的向后冒泡排序轮数： " << i + 1 << endl;
	return;
}
void main()
{
	int arr[] = { 3,4,43,22,67,1};
	int arr1[] = { 3,4,43,22,67,1 };
	int arr2[] = { 3,4,43,22,67,1 };
	int arr3[] = { 3,4,43,22,67,1 };
	int len = sizeof(arr) / sizeof(arr[1]);
	BubbleSort(arr, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	BubbleSort1(arr1, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr1[i] << " ";
	}
	cout << endl;
	BubbleSort2(arr2, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr2[i] << " ";
	}
	cout << endl;
	BubbleSort3(arr3, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr3[i] << " ";
	}
	cout << endl;
	system("pause");
}
 ~~~

结果：

![163](F:\学习专用\note\pic\163.png)

### 6.4 希尔排序（nlogn）

**不稳定**

原理：先分组，再使用插入排序

![165](F:\学习专用\note\pic\165.png)

~~~c++
#include<iostream>
using namespace std;

void ShellSort(int *arr, int len)
{
	int k;
	int gap = len;
	int tmp = 0;
	for (gap = gap / 2;gap > 0;gap /= 2)//增量gap 用于分组，并逐步减小
	{
		for (int i = gap;i < len;i++)//对每个组进行插入排序
		{
			k = i;
			tmp = arr[k];
			for (int j = i - gap;j >= 0;j -= gap)//比较分组中，i位置前面的元素
			{
				if (arr[j] > tmp)//位置调换，较大元素后移，插入tmp
				{
					arr[j + gap] = arr[j];	
                    arr[j] = tmp;
				}
			} 
		}
	}
	return;
}

void main()
{
	int arr[] = { 2,1,4,43,5,22,11,67,98,12,3 };
	int len = sizeof(arr) / sizeof(arr[1]);
	ShellSort(arr, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
}
~~~

结果：

![166](F:\学习专用\note\pic\166.png)

### 6.5 快排（nlogn）

**不稳定**

![169](F:\学习专用\note\pic\169.png)

 **思想:**

​	1.在待排序的元素任取一个元素作为基准(通常选第一个元素，但最的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；

​       2.将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；

​       3.对左右两个分区重复以上步骤直到所有元素都是有序的

~~~c++
#include<iostream>
using namespace std;


void exchange(int *arr,int l,int h)//交换元素
{
	int tmp = 0;
	tmp = arr[l];
	arr[l] = arr[h];
	arr[h] = tmp;

}
int parition(int *arr,int low,int high)
{
	int pot = arr[low];//取数组第一个元素为基准
	while (low<high)
	{
		while ((low < high) && (arr[high]) >= pot)
		{
			high--;//比基准大或相等，本来就在右边，high前移
		}
		exchange(arr,low,high);
		while ((low < high) && (arr[low]) <= pot)
		{
			low++;//比基准小或相等，本来就在左边，low后移
		}
		exchange(arr, low, high);
	}
	return low;//返回基准的位置
}
void Qsort(int *arr,int low,int high)
{
	if (low < high)
	{
		int pot = parition(arr,low,high);//根据数组的第一个元素，对数组进行划分

		Qsort(arr, low, pot - 1);//对划分后的左数组排序
		Qsort(arr, pot + 1, high);//对划分后的右数组排序
	}
}
void QuickSort(int *arr, int len)
{
	Qsort(arr, 0, len - 1);
}
void main()
{
	int arr[] = { 2,1,4,43,5,22,2,11,3,67,98,12,3 };
	int len = sizeof(arr) / sizeof(arr[1]);
	QuickSort(arr, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
}
~~~

结果:

![167](F:\学习专用\note\pic\167.png)

### 6.6 归并排序(nlogn)

![170](F:\学习专用\note\pic\170.png)



![171](F:\学习专用\note\pic\171.png)

~~~c++
#include<iostream>
using namespace std;
void Merge(int *src, int *des, int low, int mid, int high)
{
	int i = low;
	int j = mid + 1;
	int  k = low;
	while ((i <= mid) && (j < high))//将较小值放入目的数组
	{
		if (src[i] < src[j])
		{
			des[k++] = src[i++];
		}
		else
		{
			des[k++] = src[j++];
		}
	}
	while (i <= mid)//剩下的元素
	{
		des[k++] = src[i++];
	}
	while (j <= high)//剩下的元素
	{
		des[k++] = src[j++];
	}
}
void MSort(int *src,int *des,int low,int high,int max)
{
	if (low == high)//只有一个元素
	{
		des[low] = src[low];
	}
	else
	{
		int mid = (low + high) / 2;
		int *space = (int *)malloc(sizeof(int)*max);

		if (space != NULL)
		{
			MSort(src, space, low, mid, max);
			MSort(src, space, mid+1,high, max);
			Merge(space,des,low,mid,high);//调用归并函数进行归并
		}
		free(space);
	}

}

void MergeSort(int *arr,int len)
{
	MSort(arr,arr,0,len-1,len);
}
void main()
{
	int arr[] = { 2,1,4,43,5,22,2,11,3,67,98,12,3 };
	int len = sizeof(arr) / sizeof(arr[1]);
	MergeSort(arr, len);
	for (int i = 0;i < len;i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
	system("pause");
}
~~~

