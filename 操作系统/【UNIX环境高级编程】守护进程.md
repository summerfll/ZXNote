# 【UNIX环境高级编程】守护进程

## 1.引言

守护进程也称精灵进程，是生存期较长的一种进程。它们通常在系统自举时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以它们都是在后台运行的。

## 2.守护进程的特征

![47](F:\学习专用\学习笔记\图片\47.png)

各标题意义：父进程ID，进程ID，进程组ID，会话ID,终端名称，终端进程组ID，用户ID

系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程，它们作为系统自举过程的一部分而启动。进程1通常是init，它是一个系统守护进程，负责启动各运行层次特定的系统服务。



- 在Linux下，kenentd守护进程为在内核中运行计划执行的函数提供进程上下文。

​		     kapmd守护进程对很多计算机系统中具有的高级电源管理提供支持。

​	             kswapd守护进程也称为页面调出守护进程，通过将脏页面以低速写到磁盘上从而使这些页面在需要时仍可回收。

- Linux内核使用bdflush和kupdated将高速缓冲中的数据冲洗到磁盘上。
- 大多数守护进程都以超级用户（用户ID为0）特权运行。没有一个守护进程具有控制终端，其终端名设置为问号（？），终端前台进程组ID设置为-1
- 大多数守护进程的父进程是init进程

## 3.编程规则

编写守护进程需遵循一定的规则

- 首先要做的是调用umask将文件模式创建屏蔽字设置为0
- 调用fork，然后使父进程退出（exit），这样做实现下面几点：（1）如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕，（2）子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。
- 调用setsid以创建一个新会话，使调用进程：（1）成为新会话的首进程，（2）成为一个新进程组的组长进程，（3）没有控制终端
- 将当前工作目录更改为根目录
- 关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的某些文件描述符
- 某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入，写标准输出或标准出错的库例程都不会产生任何效果。

## 4.出错记录

与守护进程有关的一个问题是如何处理出错信息。

## 5.单实例守护进程

为了正常运行，某些守护进程实现为单实例的，在任意时刻只运行该守护进程的一个副本。



​		     

